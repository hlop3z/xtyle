/*! @License MIT | Copyright (c) 2022 hlop3z */
var xtyle = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/__init__.js
  var init_exports = {};
  __export(init_exports, {
    default: () => init_default
  });

  // src/reactive.js
  function deepMerge(target, ...sources) {
    sources.forEach((source) => {
      for (let key in source) {
        if (source[key] instanceof Object) {
          if (!target[key])
            Object.assign(target, { [key]: {} });
          deepMerge(target[key], source[key]);
        } else {
          Object.assign(target, { [key]: source[key] });
        }
      }
    });
    return target;
  }
  function mergeObjects(obj1, obj2, avoidModification = false) {
    if (avoidModification) {
      return deepMerge(Object.assign({}, obj1), obj2);
    } else {
      return deepMerge(obj1, obj2);
    }
  }
  function compare(obj1, obj2) {
    if (obj1 === obj2)
      return true;
    if (typeof obj1 !== "object" || obj1 === null || typeof obj2 !== "object" || obj2 === null)
      return false;
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length)
      return false;
    for (const key of keys1) {
      if (!keys2.includes(key))
        return false;
      if (!compare(obj1[key], obj2[key]))
        return false;
    }
    return true;
  }
  function produce(current, method) {
    const draft = Object.assign({}, current);
    method(draft);
    const next = mergeObjects(current, draft, true);
    const update = compare(current, next);
    return { data: next, update: !update };
  }
  var Reactive = class {
    constructor(reactObject) {
      const defaultValue = { ...reactObject };
      this.original = defaultValue;
      this.current = defaultValue;
      this.vdom = null;
    }
    get state() {
      return this.current;
    }
    set state(method) {
      this.update(method);
    }
    update(method) {
      const { data, update } = produce(this.current, method);
      if (update) {
        this.current = data;
        if (this.vdom) {
          this.vdom.render();
        }
      }
    }
    reset() {
      this.current = this.original;
    }
  };
  function reactive(key, originalData) {
    return new Reactive(key, originalData);
  }
  var reactive_default = {
    model: reactive,
    produce,
    compare,
    merge: mergeObjects
  };

  // src/diff.js
  function diff(oldNode, newNode) {
    if (!oldNode) {
      return newNode;
    }
    if (!newNode) {
      oldNode.remove();
      return null;
    }
    if (oldNode.key !== newNode.key) {
      oldNode.replaceWith(newNode);
      return newNode;
    }
    if (changed(oldNode, newNode)) {
      oldNode.replaceWith(newNode);
      return newNode;
    }
    if (oldNode.tagName !== newNode.tagName) {
      oldNode.replaceWith(newNode);
      return newNode;
    }
    let oldAttrs = oldNode.attributes;
    let newAttrs = newNode.attributes;
    let attrs = diffAttrs(oldAttrs, newAttrs);
    for (let i = 0; i < attrs.length; i++) {
      let attr = attrs[i];
      oldNode.setAttribute(attr.name, attr.value);
    }
    diffChildren(oldNode, newNode);
    return oldNode;
  }
  function changed(oldNode, newNode) {
    return oldNode.textContent !== newNode.textContent;
  }
  function diffAttrs(oldAttrs, newAttrs) {
    let attrs = [];
    if (oldAttrs) {
      for (let i = 0; i < newAttrs.length; i++) {
        let newAttr = newAttrs[i];
        let oldAttr = oldAttrs.getNamedItem(newAttr.name);
        if (!oldAttr || oldAttr.value !== newAttr.value) {
          attrs.push({
            name: newAttr.name,
            value: newAttr.value
          });
        }
      }
    }
    return attrs;
  }
  function diffChildren(oldNode, newNode) {
    let oldChildren = Array.from(oldNode.childNodes);
    let newChildren = Array.from(newNode.childNodes);
    for (let i = 0; i < newChildren.length || i < oldChildren.length; i++) {
      let newChild = newChildren[i];
      let oldChild = oldChildren[i];
      let node = diff(oldChild, newChild);
      if (node && !oldNode.contains(node)) {
        oldNode.appendChild(node);
      }
    }
  }
  var diff_default = diff;

  // src/ripple.js
  var prefixCSS = "gui-design";
  function inject(props) {
    const ID = props.id;
    const stringTemplate = props.code;
    function getStyle(id) {
      const found = window.document.querySelectorAll(`[${prefixCSS}="${id}"]`);
      if (found.length > 0) {
        return found[0];
      } else {
        const style = window.document.createElement("style");
        style.setAttribute(prefixCSS, id);
        window.document.head.append(style);
        return style;
      }
    }
    function removeSpace(text) {
      return text.replace(/\s\s+/g, " ").replace(/\r?\n|\r/g, "").trim();
    }
    const elem = getStyle(ID);
    elem.textContent = removeSpace(stringTemplate);
  }
  var cssClass = {
    container: "v-ripple__container",
    animation: "v-ripple__animation",
    enter: "v-ripple__animation--enter",
    visible: "v-ripple__animation--visible",
    start: "v-ripple__animation--start",
    end: "v-ripple__animation--end",
    style: `.v-ripple__animation,.v-ripple__container{color:inherit;position:absolute;top:0;left:0;pointer-events:none;overflow:hidden}.v-ripple__container{border-radius:inherit;width:100%;height:100%;z-index:0;contain:strict}.v-ripple__animation{border-radius:50%;background:currentColor;opacity:0;will-change:transform,opacity}.v-ripple__animation--enter{transition:none}.v-ripple__animation--start{transition:transform .25s cubic-bezier(.4, 0, .2, 1),opacity .1s cubic-bezier(.4, 0, .2, 1)}.v-ripple__animation--end{transition:opacity .3s cubic-bezier(.4, 0, .2, 1)}`
  };
  inject({
    id: "ripple-fx",
    code: cssClass.style
  });
  function transform(el, value) {
    el.style["transform"] = value;
    el.style["webkitTransform"] = value;
  }
  function opacity(el, value) {
    el.style["opacity"] = value.toString();
  }
  function isTouchEvent(e) {
    return e.constructor.name === "TouchEvent";
  }
  var calculate = (e, el, value = {}) => {
    const offset = el.getBoundingClientRect();
    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    const localX = target.clientX - offset.left;
    const localY = target.clientY - offset.top;
    let radius = 0;
    let scale = 0.3;
    if (el._ripple && el._ripple.circle) {
      scale = 0.15;
      radius = el.clientWidth / 2;
      radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
    } else {
      radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
    }
    const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
    const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
    const x = value.center ? centerX : `${localX - radius}px`;
    const y = value.center ? centerY : `${localY - radius}px`;
    return { radius, scale, x, y, centerX, centerY };
  };
  var ripples = {
    /* eslint-disable max-statements */
    show(e, el, value = {}) {
      if (!el._ripple || !el._ripple.enabled) {
        return;
      }
      const container = document.createElement("span");
      const animation = document.createElement("span");
      container.appendChild(animation);
      container.className = cssClass.container;
      if (value.class) {
        container.className += ` ${value.class}`;
      }
      const { radius, scale, x, y, centerX, centerY } = calculate(e, el, value);
      const size = `${radius * 2}px`;
      animation.className = cssClass.animation;
      animation.style.width = size;
      animation.style.height = size;
      if (el._ripple && el._ripple.color) {
        animation.style.color = el._ripple.color;
      }
      el.appendChild(container);
      const computed = window.getComputedStyle(el);
      if (computed && computed.position === "static") {
        el.style.position = "relative";
        el.dataset.previousPosition = "static";
      }
      animation.classList.add(cssClass.enter);
      animation.classList.add(cssClass.visible);
      transform(
        animation,
        `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`
      );
      opacity(animation, 0);
      animation.dataset.activated = String(performance.now());
      setTimeout(() => {
        animation.classList.remove(cssClass.enter);
        animation.classList.add(cssClass.start);
        transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
        opacity(animation, 0.25);
      }, 0);
    },
    hide(el) {
      if (!el || !el._ripple || !el._ripple.enabled)
        return;
      const ripples2 = el.getElementsByClassName(cssClass.animation);
      if (ripples2.length === 0)
        return;
      const animation = ripples2[ripples2.length - 1];
      if (animation.dataset.isHiding)
        return;
      else
        animation.dataset.isHiding = "true";
      const diff2 = performance.now() - Number(animation.dataset.activated);
      const delay = Math.max(250 - diff2, 0);
      setTimeout(() => {
        animation.classList.remove(cssClass.start);
        animation.classList.add(cssClass.end);
        opacity(animation, 0);
        setTimeout(() => {
          const ripples3 = el.getElementsByClassName(cssClass.animation);
          if (ripples3.length === 1 && el.dataset.previousPosition) {
            el.style.position = el.dataset.previousPosition;
            delete el.dataset.previousPosition;
          }
          animation.parentNode && el.removeChild(animation.parentNode);
        }, 300);
      }, delay);
    }
  };
  function isRippleEnabled(value) {
    return typeof value === "undefined" || !!value;
  }
  function rippleShow(e) {
    const value = {};
    const element2 = e.currentTarget;
    if (!element2 || !element2._ripple || element2._ripple.touched)
      return;
    if (isTouchEvent(e)) {
      element2._ripple.touched = true;
      element2._ripple.isTouch = true;
    } else {
      if (element2._ripple.isTouch)
        return;
    }
    value.center = element2._ripple.centered;
    if (element2._ripple.class) {
      value.class = element2._ripple.class;
    }
    ripples.show(e, element2, value);
  }
  function rippleHide(e) {
    const element2 = e.currentTarget;
    if (!element2)
      return;
    window.setTimeout(() => {
      if (element2._ripple) {
        element2._ripple.touched = false;
      }
    });
    ripples.hide(element2);
  }
  function startListeners(el, setup, wasEnabled) {
    const enabled = isRippleEnabled(setup);
    if (!enabled) {
      ripples.hide(el);
    }
    el._ripple = el._ripple || {};
    el._ripple.enabled = enabled;
    const value = setup || {};
    if (value.center) {
      el._ripple.centered = true;
    }
    if (value.class) {
      el._ripple.class = setup.class;
    }
    if (value.circle) {
      el._ripple.circle = setup.circle;
    }
    if (value.color) {
      el._ripple.color = setup.color;
    }
    if (enabled && !wasEnabled) {
      el.addEventListener("touchstart", rippleShow, { passive: true });
      el.addEventListener("touchend", rippleHide, { passive: true });
      el.addEventListener("touchcancel", rippleHide);
      el.addEventListener("mousedown", rippleShow);
      el.addEventListener("mouseup", rippleHide);
      el.addEventListener("mouseleave", rippleHide);
      el.addEventListener("dragstart", rippleHide, { passive: true });
    } else if (!enabled && wasEnabled) {
      stopListeners(el);
    }
  }
  function stopListeners(el) {
    el.removeEventListener("mousedown", rippleShow);
    el.removeEventListener("touchstart", rippleHide);
    el.removeEventListener("touchend", rippleHide);
    el.removeEventListener("touchcancel", rippleHide);
    el.removeEventListener("mouseup", rippleHide);
    el.removeEventListener("mouseleave", rippleHide);
    el.removeEventListener("dragstart", rippleHide);
  }
  var ripple_default = (el, setup) => startListeners(el, setup, false);

  // src/hyperscript.js
  var ALL_EVENTS = [
    "click",
    "dblclick",
    "mousedown",
    "mouseup",
    "contextmenu",
    "mouseout",
    "mousewheel",
    "mouseover",
    "touchstart",
    "touchend",
    "touchmove",
    "touchcancel",
    "keydown",
    "keyup",
    "keypress",
    "focus",
    "blur",
    "change",
    "submit",
    "resize",
    "scroll",
    "hashchange"
  ];
  function setAttributes(node, attributes) {
    if (attributes) {
      for (let attr in attributes) {
        if (attr === "show") {
          if (attributes[attr] === false) {
            node.hidden = true;
            return true;
          }
        }
        if (attr !== "key" && attr !== "show") {
          if (attr.startsWith("x-")) {
            if (attr.startsWith("x-on:")) {
              let eventType = attr.slice(5);
              if (ALL_EVENTS.includes(eventType)) {
                node.addEventListener(eventType, attributes[attr]);
              }
            } else {
              if ("x-ripple") {
                const _config = attributes[attr];
                let config = {};
                if (_config) {
                  config = new Function("return " + _config)();
                }
                ripple_default(node, config);
              }
            }
          } else if (attr === "class") {
            if (Array.isArray(attributes[attr])) {
              node.setAttribute(attr, attributes[attr].join(" "));
            } else {
              if (attributes[attr]) {
                node.setAttribute(attr, attributes[attr]);
              }
            }
          } else {
            node.setAttribute(attr, attributes[attr]);
          }
        }
      }
    }
  }
  function h(tagName, attributes, children) {
    if (!tagName)
      return () => null;
    if (tagName === "template")
      return h(...children[0]);
    const node = document.createElement(tagName);
    function WrappParent(parent = null) {
      const empty = setAttributes(node, attributes);
      if (empty) {
        return node;
      }
      if (!Array.isArray(children)) {
        children = [children];
      }
      children.forEach((child) => {
        if (child) {
          if (child instanceof Component) {
            child.$root = node;
            child.$parent = parent;
            const vnode = child.render();
            if (vnode) {
              node.appendChild(vnode);
            }
          } else if (typeof child === "object") {
            if (child[0] === "template") {
              fragment(...child[2]).forEach((fragmented) => {
                node.appendChild(fragmented);
              });
            } else {
              node.appendChild(h(...child)());
            }
          } else {
            node.appendChild(document.createTextNode(child));
          }
        }
      });
      return node;
    }
    return WrappParent;
  }
  var hyperscript_default = h;
  function createFragment(item) {
    if (typeof item !== "string" && item) {
      const [tag, attributes, children] = item;
      const node = document.createElement(tag);
      const empty = setAttributes(node, attributes);
      if (empty) {
        return node;
      }
      children.forEach((child) => {
        node.appendChild(createFragment(child));
      });
      return node;
    } else {
      return document.createTextNode(item);
    }
  }
  function fragment(...items) {
    return items.map((item) => createFragment(item));
  }
  function createSingletonElement(root, uniqueID) {
    let count = 0;
    let current = null;
    let rootElement = null;
    if (typeof root === "string") {
      rootElement = document.getElementById(root);
    } else {
      rootElement = root;
    }
    const foundEditor = document.getElementById(uniqueID);
    if (!foundEditor) {
      count += 1;
      const newEditor = document.createElement("div");
      newEditor.setAttribute("id", uniqueID);
      rootElement.appendChild(newEditor);
      current = newEditor;
    } else {
      current = foundEditor;
    }
    return { el: current, init: foundEditor ? true : false };
  }
  function attachToBody(uniqueID) {
    const element2 = document.getElementById(uniqueID);
    if (!element2) {
      const newEditor = document.createElement("div");
      newEditor.setAttribute("id", uniqueID);
      document.body.appendChild(newEditor);
    }
  }
  var createFromHyperList = (hscript) => {
    const [tag, attributes, children] = hscript;
    const node = document.createElement(tag);
    const empty = setAttributes(node, attributes);
    if (empty) {
      return node;
    }
    children.forEach((child) => {
      if (Array.isArray(child)) {
        node.appendChild(createFromHyperList(child));
      } else {
        node.appendChild(document.createTextNode(child));
      }
    });
    return node;
  };
  var element = {
    create: createSingletonElement,
    attach: attachToBody,
    h: createFromHyperList
  };

  // src/component.js
  function mountToRoot(root, velement) {
    let vnode = "";
    let parentNode = null;
    if ("string" === typeof root) {
      parentNode = document.querySelector(root);
      vnode = velement.render();
      velement.$el = vnode;
    } else {
      parentNode = root;
      vnode = velement.render();
      velement.$el = vnode;
    }
    if (vnode === null) {
      parentNode.replaceWith("");
    } else {
      parentNode.replaceWith(vnode);
    }
  }
  var Component = class {
    constructor(setup) {
      this.$el = null;
      this.$root = null;
      this.$parent = null;
      const { admin, component, internalObject, init } = setup;
      this.__dict__ = admin;
      admin.vdom = this;
      Object.defineProperty(internalObject, "$el", {
        get: () => {
          return this.$el;
        }
      });
      Object.defineProperty(internalObject, "$parent", {
        get: () => {
          return this.$parent;
        }
      });
      Object.defineProperty(internalObject, "$gui", {
        get: () => {
          return window.$____XPRIVATEDICTX____$.components;
        }
      });
      Object.defineProperty(internalObject, "$ui", {
        get: () => {
          return window.$____XPRIVATEDICTX____$;
        }
      });
      Object.keys(component.sync).forEach((childKey) => {
        const parentKey = component.sync[childKey];
        Object.defineProperty(internalObject, childKey, {
          get: () => {
            return this.$parent.data[parentKey];
          },
          set: (value) => {
            this.$parent.data = (draft) => {
              draft[parentKey] = value;
            };
          }
        });
      });
      internalObject.$emit = (action, value = null) => {
        if (this.$parent) {
          if (action.startsWith("update:")) {
            const [ignore, key] = action.split(":");
            this.$parent.data = (draft) => {
              draft[key] = value;
            };
          } else if (action.startsWith("update")) {
            this.$parent.data = (draft) => {
              Object.keys(value).forEach((key) => {
                draft[key] = value[key];
              });
            };
          } else {
            const { getInternalObject } = this.$parent;
            if (getInternalObject[action]) {
              getInternalObject[action](value);
            }
          }
        }
      };
      component.methods(internalObject);
      this.view = component.view(internalObject);
      this.getInternalObject = internalObject;
      this.$events = {};
      this.$events.init = () => init(() => {
        const globalKeys = component.follow ? component.follow : [];
        if (globalKeys.length > 0) {
          window.addEventListener("xtyleGlobalsUpdate", (event) => {
            const { namespace } = event.detail;
            if (globalKeys.includes(namespace)) {
              this.render();
            }
          });
        }
      });
      this.$events.mounted = component.mounted.bind(internalObject);
    }
    get data() {
      return this.__dict__.state;
    }
    set data(method) {
      return this.__dict__.update(method);
    }
    render() {
      const view = this.view();
      if (view) {
        let newData = hyperscript_default(...view)(this);
        this.$el = diff_default(this.$el, newData);
      }
      this.$events.init();
      this.$events.mounted();
      return this.$el;
    }
    mount(root = null) {
      if (this.$root) {
        mountToRoot(this.$root, this);
      } else {
        this.$root = root;
        mountToRoot(root, this);
      }
    }
    unmount() {
      this.$el.remove();
    }
  };
  var checkTypeName = {
    [String]: "String",
    [Number]: "Number",
    [Function]: "Function",
    [Array]: "Array",
    [null]: "NULL",
    [Object]: "Object",
    [Boolean]: "Boolean",
    [void 0]: "UNDEFINED"
  };
  var checkType = (value) => {
    if (typeof value === "string") {
      return { name: checkTypeName[String], type: String };
    } else if (typeof value === "number") {
      return { name: checkTypeName[Number], type: Number };
    } else if (typeof value === "boolean") {
      return { name: checkTypeName[Boolean], type: Boolean };
    } else if (typeof value === "function") {
      return { name: checkTypeName[Function], type: Function };
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        return { name: checkTypeName[Array], type: Array };
      } else if (value === null) {
        return { name: checkTypeName[null], type: null };
      } else {
        return { name: checkTypeName[Object], type: Object };
      }
    } else {
      return { name: checkTypeName[Function], type: void 0 };
    }
  };
  function createProps(component, userInput) {
    const inputObject = userInput ? userInput : {};
    const componentObject = {};
    const propsKeys = Object.keys(component.props);
    propsKeys.forEach((item) => {
      let value = inputObject[item];
      const currentType = component.props[item].type;
      const expectedType = checkTypeName[currentType];
      if (value && currentType !== Boolean) {
        if (currentType === String) {
          value = value.toString();
        }
        const inputType = checkType(value);
        const isValid = currentType === inputType.type;
        if (!isValid) {
          if (["Function", "Object", "Array"].includes(expectedType)) {
            value = component.props[item].default();
          } else {
            value = component.props[item].default;
          }
          console.error(
            `prop: { ${item} } is not of the value { ${expectedType} }`
          );
        }
      } else if (currentType === Boolean) {
        const currentVal = value === void 0 ? null : value;
        value = currentVal;
      } else {
        if (["Function", "Object", "Array"].includes(expectedType)) {
          value = component.props[item].default();
        } else {
          value = component.props[item].default;
        }
      }
      componentObject[item] = value;
    });
    return Object.assign({}, { ...component.data, ...componentObject });
  }
  function methodBind(element2, vnode) {
    Object.keys(element2.methods).forEach((item) => {
      const method = element2.methods[item];
      vnode[item] = method.bind(vnode);
    });
    return vnode;
  }
  function viewBind(element2, vnode) {
    return element2.view.bind(vnode);
  }
  function ComponentBase(options) {
    const element2 = {
      follow: options.follow || [],
      sync: options.sync || {},
      props: options.props || {},
      data: options.data || {},
      methods: options.methods || {},
      view: options.view || function() {
      },
      components: options.components || {},
      mounted: options.mounted || function() {
      },
      init: options.init || function() {
      }
    };
    const elementProps = {};
    elementProps.__keys__ = Array.from(
      /* @__PURE__ */ new Set([...Object.keys(element2.props), ...Object.keys(element2.data)])
    );
    elementProps.__methods__ = Array.from(new Set(Object.keys(element2.methods)));
    elementProps.props = (props) => createProps(element2, props);
    elementProps.methods = (vnode) => methodBind(element2, vnode);
    elementProps.view = (vnode) => viewBind(element2, vnode);
    elementProps.follow = element2.follow;
    elementProps.sync = element2.sync;
    elementProps.mounted = element2.mounted;
    elementProps.init = element2.init;
    return elementProps;
  }
  function defineComponent(setup) {
    const component = ComponentBase(setup);
    let init = false;
    function createComponent(inputProps) {
      const componentProps = inputProps ? inputProps : {};
      const props = component.props(componentProps);
      const admin = reactive_default.model(props);
      const internalObject = {};
      function setProperty2(key) {
        Object.defineProperty(internalObject, key, {
          get: function() {
            return admin.state[key];
          },
          set: function(value) {
            admin.update((draft) => draft[key] = value);
          }
        });
      }
      component.__keys__.forEach((key) => {
        setProperty2(key);
      });
      internalObject.$slot = (key, opts) => {
        if (componentProps.$slot[key]) {
          return componentProps.$slot[key](opts);
        } else {
          return null;
        }
      };
      internalObject.$update = (method) => admin.update(method);
      const runOnce = (method) => {
        if (init === false) {
          init = true;
          method();
          component.init.bind(internalObject)();
        }
      };
      return new Component({ component, internalObject, admin, init: runOnce });
    }
    return createComponent;
  }
  function buildComponents(components) {
    const componentLib = {};
    components.forEach((item) => {
      componentLib[item.name] = defineComponent(item);
    });
    return componentLib;
  }
  var component_default = defineComponent;

  // src/namespace.js
  var GLOBAL_EVENT = "xtyleGlobalsUpdate";
  var AVLNode = class {
    constructor(key, value) {
      this.key = key;
      this.value = value;
      this.left = null;
      this.right = null;
      this.height = 1;
    }
  };
  var AVLTree = class {
    constructor() {
      this.root = null;
      this.__keys__ = /* @__PURE__ */ new Set();
    }
    get keys() {
      return Array.from(this.__keys__);
    }
    create(key, value) {
      this.root = this._insert(key, value, this.root);
      this.__keys__.add(key);
      return this;
    }
    _insert(key, value, node) {
      if (!node) {
        return new AVLNode(key, value);
      }
      if (key < node.key) {
        node.left = this._insert(key, value, node.left);
      } else {
        node.right = this._insert(key, value, node.right);
      }
      node.height = 1 + Math.max(this._height(node.left), this._height(node.right));
      const balance = this._getBalance(node);
      if (balance > 1 && key < node.left.key) {
        return this._rotateRight(node);
      }
      if (balance < -1 && key > node.right.key) {
        return this._rotateLeft(node);
      }
      if (balance > 1 && key > node.left.key) {
        node.left = this._rotateLeft(node.left);
        return this._rotateRight(node);
      }
      if (balance < -1 && key < node.right.key) {
        node.right = this._rotateRight(node.right);
        return this._rotateLeft(node);
      }
      return node;
    }
    read(key) {
      return this._find(key, this.root);
    }
    _find(key, node) {
      if (!node) {
        return null;
      }
      if (key === node.key) {
        return node.value;
      }
      if (key < node.key) {
        return this._find(key, node.left);
      }
      return this._find(key, node.right);
    }
    _height(node) {
      if (!node) {
        return 0;
      }
      return node.height;
    }
    _getBalance(node) {
      if (!node) {
        return 0;
      }
      return this._height(node.left) - this._height(node.right);
    }
    _rotateRight(node) {
      const { left } = node;
      const leftRight = left.right;
      left.right = node;
      node.left = leftRight;
      node.height = 1 + Math.max(this._height(node.left), this._height(node.right));
      left.height = 1 + Math.max(this._height(left.left), this._height(left.right));
      return left;
    }
    _rotateLeft(node) {
      const { right } = node;
      const rightLeft = right.left;
      right.left = node;
      node.right = rightLeft;
      node.height = 1 + Math.max(this._height(node.left), this._height(node.right));
      right.height = 1 + Math.max(this._height(right.left), this._height(right.right));
      return right;
    }
    update(key, value) {
      let current = this.root;
      while (current) {
        if (key === current.key) {
          current.value = value;
          return true;
        }
        if (key < current.key) {
          current = current.left;
        } else {
          current = current.right;
        }
      }
      return false;
    }
    delete(key) {
      this.root = this._delete(key, this.root);
    }
    _delete(key, node) {
      if (!node) {
        return null;
      }
      if (key < node.key) {
        node.left = this._delete(key, node.left);
      } else if (key > node.key) {
        node.right = this._delete(key, node.right);
      } else {
        if (!node.left) {
          return node.right;
        }
        if (!node.right) {
          return node.left;
        }
        const minNode = this._findMinNode(node.right);
        node.key = minNode.key;
        node.value = minNode.value;
        node.right = this._delete(minNode.key, node.right);
      }
      node.height = 1 + Math.max(this._height(node.left), this._height(node.right));
      const balance = this._getBalance(node);
      if (balance > 1 && this._getBalance(node.left) >= 0) {
        return this._rotateRight(node);
      }
      if (balance > 1 && this._getBalance(node.left) < 0) {
        node.left = this._rotateLeft(node.left);
        return this._rotateRight(node);
      }
      if (balance < -1 && this._getBalance(node.right) <= 0) {
        return this._rotateLeft(node);
      }
      if (balance < -1 && this._getBalance(node.right) > 0) {
        node.right = this._rotateRight(node.right);
        return this._rotateLeft(node);
      }
      return node;
    }
    _findMinNode(node) {
      if (!node.left) {
        return node;
      }
      return this._findMinNode(node.left);
    }
  };
  var reactiveTree = new AVLTree();
  function setProperty(target, key) {
    Object.defineProperty(target, key, {
      get: function() {
        return target.$____state____$[key];
      },
      set: function(value) {
        target.$____update____$((draft) => draft[key] = value);
      }
    });
  }
  var SimpleNamespace = class {
    constructor(namespace, kwargs) {
      const objKeys = Object.keys(kwargs);
      const $namespace = namespace.toLowerCase();
      this.$____namespace____$ = $namespace;
      this.$____dict____$ = kwargs;
      this.$____keys____$ = objKeys;
      reactiveTree.create($namespace, kwargs);
      objKeys.forEach((key) => {
        setProperty(this, key);
      });
    }
    $redraw() {
      const { redraw } = window.$____XPRIVATEDICTX____$.router;
      if (redraw) {
        redraw();
      }
    }
    get $update() {
      return this.$____update____$;
    }
    get $store() {
      return reactiveTree;
    }
    get $____state____$() {
      return reactiveTree.read(this.$____namespace____$);
    }
    $____update____$(method) {
      const { data, update } = reactive_default.produce(this.$____dict____$, method);
      if (update) {
        const namespace = this.$____namespace____$;
        this.$____dict____$ = data;
        reactiveTree.update(namespace, data);
        let event = new CustomEvent(GLOBAL_EVENT, {
          detail: { namespace }
        });
        window.dispatchEvent(event);
      }
    }
  };
  function createSimpleNamespace(namespace, kwargs) {
    return new SimpleNamespace(namespace, kwargs);
  }
  var namespace_default = createSimpleNamespace;

  // src/router.js
  window.$____XPRIVATEDICTX____$ = {
    router: {},
    components: {},
    static: {},
    methods: {},
    vars: {},
    current: null
  };
  var GLOBALS = window.$____XPRIVATEDICTX____$;
  var Page404 = component_default({
    props: {
      title: {
        type: String,
        default: "Oops!"
      }
    },
    view() {
      return [
        "div",
        {
          style: "text-align: center"
        },
        [
          [
            "h1",
            {
              style: "font-size: 8.5em"
            },
            [this.title]
          ],
          ["h3", {}, "404 | Page not Found."]
        ]
      ];
    }
  });
  function fixURL(path) {
    path = "/" + path.replace(/^\/|\/$/g, "") + "/";
    return path;
  }
  function extractSearchParams(_path) {
    const searchParams = new URLSearchParams(_path);
    const obj = {};
    searchParams.forEach((value, key) => {
      obj[key] = value;
    });
    return obj;
  }
  function extractPathArgs(_template, _path) {
    const template = fixURL(_template);
    const path = fixURL(_path);
    let regexp = new RegExp(template.replace(/{(.*?)}/g, "([^/]+)"));
    let match = path.match(regexp);
    let params = {};
    if (match) {
      const found = template.match(/{(.*?)}/g);
      if (found) {
        found.forEach((key, i) => {
          params[key.slice(1, -1)] = match[i + 1];
        });
      }
    }
    return params;
  }
  function validPath(_template, _path) {
    const template = fixURL(_template);
    const path = fixURL(_path);
    let regexp = new RegExp("^" + template.replace(/{(.*?)}/g, "([^/]+)") + "$");
    return regexp.test(path);
  }
  function getPathRoute(routes, currentPath) {
    const found = Object.keys(routes).filter(
      (route) => validPath(route, currentPath)
    );
    if (found.length > 0) {
      return found[0];
    }
    return "404";
  }
  function mountRouter(setup) {
    const options = setup ? setup : {};
    let root = options.root ? options.root : "#app";
    let history = options.history ? options.history : false;
    let routes = options.routes ? options.routes : {};
    let appComponents = options.components ? options.components : [];
    let appMethods = options.methods ? options.methods : {};
    let appStatic = options.static ? options.static : {};
    let appVars = options.vars ? options.vars : {};
    let vdom = null;
    let route = null;
    let routerPath = null;
    let currentPath = null;
    let pathParams = {};
    let searchQuery = {};
    if (!history) {
      if (!window.location.hash)
        window.location.hash = "/";
    }
    const navigate = (path) => {
      const event = window.event;
      if (event) {
        try {
          if (event.preventDefault) {
            event.preventDefault();
          }
          if (event.stopPropagation) {
            event.stopPropagation();
          }
          if (event.stopImmediatePropagation) {
            event.stopImmediatePropagation();
          }
        } catch (e) {
          e;
        }
      }
      if (history) {
        window.history.pushState({}, "", path);
      } else {
        window.location.hash = path;
      }
      handleLocation();
    };
    async function handleLocation() {
      currentPath = history ? window.location.pathname : window.location.hash.slice(1);
      routerPath = getPathRoute(routes, currentPath);
      const splitPath = currentPath.split("?");
      pathParams = extractPathArgs(routerPath, splitPath[0]);
      if (splitPath.length > 1) {
        searchQuery = extractSearchParams(splitPath[1]);
      }
      route = routes[routerPath] || routes[404] || Page404;
      if (vdom) {
        vdom.unmount();
      }
      if (route) {
        vdom = route();
        vdom.mount(root);
        GLOBALS.current = vdom;
      }
    }
    function reDraw() {
      vdom.render();
    }
    window.onpopstate = handleLocation;
    const routerAdmin = {
      go: (path) => navigate(path),
      redraw: () => reDraw()
    };
    Object.defineProperty(routerAdmin, "current", {
      get: function() {
        return Object.freeze({
          route: routerPath,
          path: currentPath,
          args: pathParams,
          query: searchQuery
        });
      }
    });
    GLOBALS.components = buildComponents(appComponents);
    GLOBALS.router = routerAdmin;
    GLOBALS.methods = appMethods;
    GLOBALS.static = appStatic;
    GLOBALS.vars = appVars;
    Object.keys(appVars).forEach((key) => {
      GLOBALS.vars[key] = namespace_default(key, appVars[key]);
    });
    handleLocation();
    return window.$____XPRIVATEDICTX____$;
  }
  var router_default = mountRouter;

  // src/__init__.js
  var Component2 = {
    props: {
      tag: { type: String, default: "div" },
      name: { type: String, default: "xtyle-virtual-container-app" },
      slots: { type: Array, default: () => [] },
      mounted: { type: Function, default: () => () => null },
      style: { type: Object, default: () => ({}) },
      css: { type: Object, default: () => ({}) },
      body: { type: Boolean, default: false },
      methods: { type: Object, default: () => ({}) }
    },
    data: {
      $vm: {}
    },
    mounted() {
      let vdom = null;
      if (this.body) {
        const { el } = element.create(document.body, this.name);
        vdom = el;
      } else {
        const el = this.$el;
        vdom = el;
      }
      const styleAdmin = (el, value) => {
        const elem = this.$vm[el];
        elem.style.cssText = value;
      };
      const toggleAdmin = (el, key, value = null) => {
        const elem = this.$vm[el];
        if (value !== null) {
          elem.classList.toggle(key, value);
        } else {
          elem.classList.toggle(key);
        }
      };
      const addClassAdmin = (el, value = null) => {
        const elem = this.$vm[el];
        value.trim().split(" ").forEach((cls) => {
          elem.classList.add(cls);
        });
      };
      this.slots.forEach((side) => {
        const slot = this.$slot(side, {
          vdom,
          admin: this,
          toggle: (...args) => toggleAdmin(...args),
          self: () => {
            return this.$vm[side];
          }
        });
        if (slot) {
          const vnode = element.h(slot);
          this.$vm[side] = vnode;
          vdom.appendChild(vnode);
        }
      });
      this.slots.forEach((side) => {
        const style = this.style[side];
        const cssClass2 = this.css[side];
        if (style) {
          styleAdmin(side, style);
        }
        if (cssClass2) {
          addClassAdmin(side, cssClass2);
        }
      });
      this.mounted.bind(this)();
    },
    view() {
      if (this.body) {
        return null;
      }
      return [this.tag, {}, []];
    }
  };
  var init_default = {
    h: component_default,
    app: router_default,
    element,
    view: component_default(Component2),
    inject
  };
  return __toCommonJS(init_exports);
})().default;
