{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Xtyle Library for (Preact)","text":"<p>Xtyle</p> <p>Welcome to Xtyle! Your Ultimate Directive Extension!   Enabling you to effortlessly extend your functions as global directives. Say goodbye to exporting and importing components constantly. Any <code>method</code> or <code>component</code> you register globally will be readily available throughout your whole Application.</p> <p><p>      Download (TypeScript) Template    </p> </p> <p>no-installation</p> <pre><code>&lt;script src=\"https://unpkg.com/xtyle@latest\" type=\"text/javascript\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"#description","title":"Description","text":"<p>Purpose and Goals</p> <p>The purpose of the <code>xtyle</code> tool is to revolutionize the way you develop for the browser. Our aim is to simplify the development process while maintaining compatibility with TypeScript and modern tools like VS Code. Xtyle empowers API developers by providing them with a simpler way to connect various plugins built with TypeScript/Javascript with their corresponding APIs.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Global Directives: Easily extend the behavior of your elements by declaring custom directives.</li> <li>Simplified Components: Define custom elements without the hassle of constant exporting and importing.</li> <li>Global Variables: Specify global variables that are accessible within your application's scope.</li> <li>Reactive State Management: Define global state variables that can be used reactively within your application.</li> </ul> <p>Plugins</p> <p>With <code>xtyle.use</code>, you can easily . . .</p> <ol> <li>Define Routes: Configure your route patterns using the <code>routes</code> prop to create a structured navigation flow.</li> <li>Declare Directives: Extend the behavior of your elements by declaring custom directives using the <code>directives</code> prop.</li> <li>Create Custom Elements: Define the custom elements you want to create with your plugin using the <code>elements</code> prop.</li> <li>Set Global Variables: Specify global variables within your plugin's scope using the <code>globals</code> prop.</li> <li>Reactive State Management: Define global state variables using the <code>store</code> prop to enable reactive updates.</li> </ol>"},{"location":"#core-api","title":"Core API","text":"Key Description <code>xtyle.init</code> Run Application <code>xtyle.use</code> Plugin(s) <code>xtyle.element</code> Component(s) <code>xtyle.directive</code> Directive(s) <code>xtyle.router</code> Router <code>xtyle.model</code> Model(s) <code>xtyle.base</code> Only useful with <code>TypeScript</code>"},{"location":"#x-html-directive","title":"<code>x-html</code> (Directive)","text":"<p>x-html</p> <p>Converts a regular HTML element into an Xtyle <code>&lt;Component /&gt;</code>.</p> <p>Example:</p> <pre><code>&lt;div x-html&gt;Regular div becomes a (Xtyle) Component&lt;/div&gt;\n</code></pre>"},{"location":"#x-slot-component","title":"<code>x-slot</code> (Component)","text":"<p>x-slot</p> <p>Converts a regular HTML element into an Xtyle <code>&lt;Fragment /&gt;</code>.</p> <p>Example:</p> <pre><code>&lt;x-slot&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"#creating-directives","title":"Creating Directives","text":"<p>custom &lt;div x-custom&gt;</p> <p>Registered directives will be enforced to be lower-case. Any directive you register under any given name will be prefixed with \u201c<code>x-</code>\u201d</p> <ul> <li><code>props</code> Arguments for the final Component.</li> <li><code>self</code> Arguments that construct the Component.</li> </ul> Key Description <code>self.directives.custom</code> Object where you can find your custom directive <code>self.ref.add</code> Add class(es) to the DOM element <code>self.ref.remove</code> Remove class(es) to the DOM element <code>self.ref.toggle</code> Toggle class(es) to the DOM element <code>self.ref.contains</code> Check if DOM element Contains a class <p>Example:</p> <pre><code>// \"x-demo\"\nxtyle.directive(\"demo\")((self, props) =&gt; {\npreact.useEffect(() =&gt; {\n// Self\nself.ref.add(\"class-after-init\");\nself.ref.remove(\"class-after-init\");\nself.ref.toggle([\"toggled-class\"], true);\nself.ref.contains(\"toggled-class\");\n}, []);\n// Demo\nconsole.log(\"Custom Directive\");\nconsole.log(self.directives.custom[\"demo\"]);\nconsole.log(props);\n});\n</code></pre> <p>Usage:</p> <p>\u201c<code>x-</code>\u201d Prefix</p> <pre><code>&lt;div x-demo=\"Hello World\" x-html&gt;&lt;/div&gt;\n</code></pre> <p>Directives</p> <p>Directives are a powerful tool that allows developers to reuse and encapsulate logic in their code. By leveraging custom directives, developers can effectively separate and encapsulate complex logic and low-level DOM operations, resulting in more modular and maintainable code. These directives enable the reuse of specific functionalities across multiple elements or components, promoting code consistency and reducing duplication.</p> <p>Custom directives provide a flexible and reusable approach to address unique requirements in web development. They can be used for a variety of purposes, such as applying specialized behaviors, manipulating the DOM, or implementing custom event handling. With custom directives, developers have the ability to create highly adaptable and reusable solutions that cater to specific needs.</p>"},{"location":"#creating-components","title":"Creating Components","text":"<p>custom &lt;x-component&gt;</p> <p>Registered components will be enforced to be lower-case and kebab-case. Any component you register under any given name will be prefixed with \u201c<code>x-</code>\u201d</p> <p>Example:</p> <p>A custom component that displays a title and its children.</p> <pre><code>xtyle.element(\"demo\")((props) =&gt; (\n&lt;x-slot&gt;\n&lt;h2&gt;{props.title}&lt;/h2&gt;\n{props.children}\n&lt;/x-slot&gt;\n));\n</code></pre> <p>Usage:</p> <ul> <li><code>title</code>: The title for the component.</li> </ul> <pre><code>&lt;x-demo title=\"Hello World\"&gt;\n&lt;h4&gt;Content goes here...&lt;/h4&gt;\n&lt;/x-demo&gt;\n</code></pre>"},{"location":"#creating-plugins","title":"Creating Plugins","text":"<p>xtyle.use</p> <p>Simplifying Plugin Registration:</p> <p>The <code>xtyle.use</code> function is a powerful utility that simplifies the process of registering various <code>elements</code>, <code>directives</code>, <code>globals</code>, and <code>store</code> in a single place for your plugin. This documentation will guide you through the steps to create and register your plugins effectively.</p>"},{"location":"#props","title":"Props:","text":"<ul> <li><code>routes</code>: Define your route(s) pattern(s).</li> <li><code>directives</code>: Declare custom directives to extend the behavior of your elements.</li> <li><code>elements</code>: Define the custom elements you want to create with your plugin.</li> <li><code>globals</code>: Specify global variables accessible within your plugin's scope.</li> <li><code>store</code>: Define global state variables that can be used reactively within your plugin.</li> </ul>"},{"location":"#example","title":"Example:","text":"<p>Below is an example of how to create and register a custom plugin using <code>xtyle.use</code>:</p> <pre><code>const myPlugin = {\n/** @Routes */\nroutes: [\"/my-app/\", \"/my-app/{path*}\"],\n/** @Directives */\ndirectives: {\nhtml(self, props) {\n// Logic to handle the 'html' directive\n// ...\n},\n},\n/** @Elements */\nelements: {\nbutton(props) {\nreturn &lt;button&gt;Click Me | {props.children}&lt;/button&gt;;\n},\n},\n/** @Globals */\nglobals: {\ntitle: \"Xtyle Project\",\n},\n/** @Store */\nstore: {\ncount: xtyle.signal(0),\n},\n};\n// Register the plugin\nxtyle.use(myPlugin);\n</code></pre> <p>By following this example, you've successfully created a plugin that includes:</p> <ul> <li>a custom <code>x-html</code> directive.</li> <li>a <code>x-button</code> element.</li> <li>a <code>title</code> global variable.</li> <li>a <code>count</code> store global state.</li> </ul> <p>These can now be used within your application.</p> <pre><code>// App (Demo)\nconst App = () =&gt; (\n&lt;div x-html&gt;\nCount is: {xtyle.store.count}\n&lt;x-button&gt;{xtyle.global.title}&lt;/x-button&gt;\n&lt;/div&gt;\n);\n// Reactive Count\nsetInterval(() =&gt; {\nxtyle.store.count.value += 1;\n}, 1000);\n// Render the App\npreact.render(preact.h(App), document.body);\n</code></pre> <p>Warning</p> <p>The <code>x-html</code> directive is a built-in directive.</p>"},{"location":"#init-run-application","title":"INIT Run Application","text":"<pre><code>import myPlugin from \"./plugin.ts\";\nimport Main from \"./main.tsx\";\n/**\n * @Register &lt;Plugin&gt;\n */\nxtyle.use(myPlugin);\n/**\n * @Router\n */\nconst router = {\nhistory: false,\nbaseURL: null,\n};\n/**\n * @Render\n */\nxtyle.init(Main, document.body, router);\n</code></pre>"},{"location":"#main-properties","title":"Main Properties","text":"Key Description <code>xtyle.global</code> Object where you can find your custom directive <code>xtyle.store</code> Object where you can find your custom directive <code>xtyle.router</code> Object where you can find your custom directive"},{"location":"#app-preview-variables","title":"(App) Preview Variables","text":"<pre><code>/**\n * @Router\n */\nconst router = {\nhistory: false,\nbaseURL: null,\n};\n/**\n * @StartApp\n */\nxtyle.init(Preview, document.body, router);\n/**\n * @Previews\n */\n/* Actions */\nconsole.log(\"Actions: \", xtyle.action.keys());\n/* Directives */\nconsole.log(\"Directives: \", Object.keys(xtyle.allDirectives));\n/* Globals */\nconsole.log(\"Globals: \", xtyle.global);\n/* Models */\nconsole.log(\"Models: \", xtyle.models.keys());\n/* Routes */\nconsole.log(\"Routes: \", xtyle.router.keys());\n/* Store */\nconsole.log(\"Store: \", xtyle.store);\n</code></pre>"},{"location":"css/","title":"Reactive CSS","text":"<p>Reactive CSS</p> <p>A powerful CSS solution that dynamically applies styles based on the state of an element <code>(is)</code>, distinguishing between <code>(on)</code> active and <code>(off)</code> inactive control conditions. The advantage lies in its ability to update styles without requiring a full re-rendering of the element. This approach provides a seamless and efficient way to manage element styles based on user interactions or changing states, resulting in a more responsive and interactive user experience.</p> Directive Description css-is Specifies the CSS class to apply when the condition is <code>true</code>. css-on Specifies the CSS classes to add when the condition is <code>true</code>. css-off Specifies the CSS classes to add when the condition is <code>false</code>. <p>Example:</p> <pre><code>function Component(props) {\nconst status = preact.useSignal(false);\nreturn (\n&lt;div x-html css-is={status.value} css-on=\"active\" css-off=\"inactive\"&gt;\nContent goes here...\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"hooks/","title":"Hooks","text":"<p>hook-{ method }<p>Hooks empower you to efficiently reuse stateful logic across multiple components. With hooks, you can extract and manage complex functionalities, such as managing component state, performing side effects, and handling lifecycle events, all in a modular and reusable manner. This promotes code organization and reduces code duplication, enabling you to build more maintainable and scalable applications.</p> </p> Directive Description hook-created Hook called when the component is created. hook-updated Hook called when the component is updated. hook-removed Hook called when the component is removed from the DOM. <p>Example:</p> <pre><code>&lt;div\n  x-html\n  hook-created={() =&gt; console.log(\"Component &lt;Created&gt;\")}\n  hook-updated={() =&gt; console.log(\"Component &lt;Updated&gt;\")}\n  hook-removed={() =&gt; console.log(\"Component &lt;Removed&gt;\")}\n&gt;\n  {/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"on-events/","title":"HTML/Preact \"ON\" Events","text":"<p>on-kebab-case</p> <p>A convenient wrapper for the original events used in Preact, designed to simplify event listener binding. With <code>on-</code> followed by <code>kebab-case</code>, common event handlers such as <code>onClick</code> are effortlessly transformed, enabling more intuitive and concise event handling. This cleaner syntax provides a seamless way to attach event listeners to elements in your Preact application, enhancing code readability and maintainability.</p> <p>Example:</p> <pre><code>&lt;button on-click={() =&gt; console.log(\"clicked\")} x-html&gt;\nClick Me\n&lt;/button&gt;\n</code></pre> <p>Description</p> <p>Event Listener For...</p> Directive Description on-click Click events. on-dbl-click Double-click events. on-context-menu Context menu events. on-mouse-down Mouse down events. on-mouse-up Mouse up events. on-mouse-enter Mouse enter events. on-mouse-leave Mouse leave events. on-mouse-move Mouse move events. on-key-down Key down events. on-key-up Key up events. on-key-press Key press events. on-focus Focus events. on-blur Blur events. on-change Change events. on-input Input events. on-submit Submit events. on-touch-start Touch start events. on-touch-move Touch move events. on-touch-end Touch end events. on-touch-cancel Touch cancel events. on-wheel Wheel events. on-scroll Scroll events. on-copy Copy events. on-cut Cut events. on-paste Paste events. on-composition-start Composition start events. on-composition-update Composition update events. on-composition-end Composition end events. on-load Load events. on-error Error events. on-animation-start Animation start events. on-animation-end Animation end events. on-animation-iteration Animation iteration events. on-transition-end Transition end events."},{"location":"preact/","title":"Preact (Browser)","text":"<p>Tip</p> <p>A preact wrapper for standalone usage in the browser.</p>"},{"location":"preact/#usage","title":"Usage","text":"<pre><code>const { signal } = preact;\n</code></pre>"},{"location":"preact/#properties","title":"Properties","text":"Key Description <code>h</code> Preact core <code>h</code>, used for creating virtual DOM elements. <code>render</code> Preact core <code>render</code>, used for rendering virtual DOM elements to the real DOM. <code>useState</code> Preact <code>hook</code> for managing state in functional components. <code>useEffect</code> Preact <code>hook</code> for handling side effects in functional components. <code>useRef</code> Preact <code>hook</code> for creating mutable references in functional components. <code>useCallback</code> Preact <code>hook</code> for memoizing functions in functional components. <code>signal</code> Preact <code>signals</code> for managing state in functional components. <code>computed</code> Preact <code>signals</code> used for creating computed values. <code>effect</code> Preact <code>signals</code> used for creating effects that react to signal changes. <code>batch</code> Preact <code>signals</code> used for batching multiple signal updates into a single re-render. <code>useSignalEffect</code> Preact <code>signals</code> signals for handling side effects in functional components that depend on signals. <code>useSignal</code> Preact <code>signals</code> signals for subscribing to a signal and re-rendering the component on signal change. <code>useComputed</code> Preact <code>signals</code> signals for creating and using computed values in functional components."},{"location":"slots/","title":"Slots","text":"<p>The <code>slots</code> module provides a flexible mechanism for defining and utilizing component slots within your application. Slots are placeholders within a component where content can be dynamically injected.</p>"},{"location":"slots/#key-features","title":"Key Features","text":"<ul> <li>Kebab-Case to PascalCase Conversion: Slot names are declared in kebab-case and automatically converted to PascalCase to maintain consistency and readability in code.</li> <li>Dynamic Slot Content: Allows for dynamic content to be injected into pre-defined slots, enabling flexible and reusable component design.</li> <li>Customizable Slot Components: Pre-built slot components can be further customized to meet specific application needs.</li> </ul>"},{"location":"slots/#declaring-expected-slots-in-a-component","title":"Declaring Expected Slots in a Component","text":"<p>Slots must be declared in kebab-case and will be converted to PascalCase.</p> <pre><code>// Define Slots\nconst defineSlots = (props: any) =&gt;\nxtyle.slotProps(props, [\"header\", \"main\", \"footer\"]);\n// Example Sub-Component\nconst SlotComponent = xtyle.slot({}, (props) =&gt; {\nconsole.log(\"Slot Props\", props);\nconsole.log(\"Parent Props\", props.$root);\nreturn (\n&lt;div&gt;\nChildren Slot\n{props.children}\n&lt;/div&gt;\n);\n});\n// Component with Slots (Sub-Components)\nexport default function App(props) {\nconst slots = defineSlots(props);\nreturn (\n&lt;div&gt;\n{slots.Header(SlotComponent, { extra: \"args\" } /* args */)}\n{slots.Main(SlotComponent)}\n{slots.Footer(SlotComponent)}\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"slots/#using-the-component-with-slots","title":"Using the Component with Slots","text":"<p>The <code>Slot</code> is a pre-built sub-component, which can be further customized.</p> <pre><code>&lt;App\nslot-header={({ Slot, parent, args }) =&gt; {\nconsole.log(parent, args); // args =&gt; { extra: \"args\" }\nreturn &lt;Slot my-var=\"value\"&gt;&lt;/Slot&gt;;\n}}\nslot-main={({ Slot }) =&gt; {\nreturn &lt;Slot my-var=\"mainValue\"&gt;&lt;/Slot&gt;;\n}}\nslot-footer={({ Slot }) =&gt; {\nreturn &lt;Slot my-var=\"footerValue\"&gt;&lt;/Slot&gt;;\n}}\n&gt;&lt;/App&gt;\n</code></pre>"},{"location":"slots/#benefits","title":"Benefits","text":"<ul> <li>Enhanced Readability: Consistent naming conventions improve code readability and maintainability.</li> <li>Reusability: Dynamic slot content allows for creating highly reusable and customizable components.</li> <li>Flexibility: Easily customize pre-built slot components to fit specific use cases.</li> </ul>"},{"location":"theme/","title":"Theme Colors","text":"<p>Theme colors refer to a predefined set of colors used to ensure visual consistency across a digital interface, such as a website or application. These colors are typically chosen to align with a brand's identity and to create a cohesive and aesthetically pleasing user experience.</p>"},{"location":"theme/#set-colors","title":"Set Colors","text":"<pre><code>const Theme = {\ntheme: {\nsuccess: \"#4CAF50\",\ndanger: \"#F44336\",\nwarning: \"#ff9800\",\ninfo: \"#2196F3\",\n},\nlight: {\ndanger: \"#FFEBEE\",\n},\ndark: {\ndanger: \"#B71C1C\",\n},\ndisable: [\n// \"text\", \"color\", \"border\", \"table\"\n],\n};\nxtyle.theme.set(Theme);\n</code></pre>"},{"location":"theme/#usage","title":"Usage","text":"<pre><code>&lt;!-- Background --&gt;\n&lt;div x-html theme-color=\"success\"&gt;&lt;/div&gt;\n&lt;!-- Text --&gt;\n&lt;div x-html theme-text=\"success\"&gt;&lt;/div&gt;\n&lt;!-- Border --&gt;\n&lt;div x-html theme-border=\"success\"&gt;&lt;/div&gt;\n&lt;!-- Table --&gt;\n&lt;div x-html theme-table=\"success\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"theme/#color-types","title":"Color Types","text":"<ul> <li>Background =&gt; <code>bg</code></li> <li>Text =&gt; <code>tx</code></li> <li>Border =&gt; <code>br</code></li> <li>Table =&gt; <code>tb</code></li> </ul> <pre><code>&lt;!-- Background --&gt;\n&lt;div class=\"color-bg-&lt;themeColor&gt;\"&gt;&lt;/div&gt;\n&lt;!-- Text --&gt;\n&lt;div class=\"color-bg-&lt;themeColor&gt;\"&gt;&lt;/div&gt;\n&lt;!-- Border --&gt;\n&lt;div class=\"color-br-&lt;themeColor&gt;\"&gt;&lt;/div&gt;\n&lt;!-- Table --&gt;\n&lt;div class=\"color-tb-&lt;themeColor&gt;\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"theme/#light-dark","title":"Light | Dark","text":"<pre><code>&lt;!-- Light --&gt;\n&lt;div class=\"color-bg-&lt;themeColor&gt;-light\"&gt;&lt;/div&gt;\n&lt;!-- Dark --&gt;\n&lt;div class=\"color-bg-&lt;themeColor&gt;-dark\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"control-flow/fallback/","title":"x-fallback and x-fallback-is","text":"<p>x-fallback and x-fallback-is<p>Combination of utilities that provides a seamless way to display a fallback component in case of rendering issues with the main component.</p> <p>With <code>x-fallback</code> and <code>x-fallback-is</code>, you can easily handle scenarios where the main component encounters errors or is still loading, ensuring a smooth user experience. Simply specify the fallback component and conditionally render it when needed. Enhance error handling and loading states with the versatility of <code>x-fallback</code> and <code>x-fallback-is</code>.</p> </p> <p>Example:</p> <pre><code>&lt;x-slot x-fallback-is={true} x-fallback={&lt;h1&gt;Loading...&lt;/h1&gt;}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/for/","title":"x-for and x-in","text":"<p>x-for and x-in<p>Powerful utilities that enable effortless looping through an array or range to render elements for each item.</p> <p>With <code>x-for</code> and <code>x-in</code>, you can easily iterate over an array of items or a range defined by an integer number, rendering elements dynamically. Simplify repetitive rendering tasks and enhance code readability with the flexibility of <code>x-for</code> and <code>x-in</code>.</p> </p> <p>Example:</p> <pre><code>&lt;x-slot\nx-for={(item) =&gt; &lt;li&gt;{item}&lt;/li&gt;}\nx-in={[\"one\", \"two\", \"three\"]}\n&gt;&lt;/x-slot&gt;\n</code></pre> <p>Range Example:</p> <pre><code>&lt;x-slot x-for={(item) =&gt; &lt;li&gt;{item}&lt;/li&gt;} x-in={3}&gt;&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/if/","title":"x-if","text":"<p>x-if<p>Utility for enabling conditional rendering of elements based on specified conditions. With x-if, you can effortlessly control whether an element should be rendered or hidden, depending on the truthiness of the provided condition. This feature allows you to create dynamic and responsive user interfaces by conditionally showing or hiding elements as needed. Simplify your component logic and enhance user experiences with the flexibility of x-if.</p> </p> <p>Example:</p> <pre><code>function Component(props) {\nconst status = preact.useSignal(false);\nreturn (\n&lt;div x-html x-if=\"{status.value}\"&gt;\nHide and Seek\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"control-flow/live/","title":"x-live","text":"<p>x-live<p>Utility that dynamically renders a component based on the provided callback function.</p> <p>With <code>x-live</code>, you can create highly flexible and dynamic components that adapt their content based on the callback's output. This feature allows you to generate custom UI elements or complex structures on the fly, providing a more interactive and adaptive user experience. Unlock the full potential of component rendering with the versatility of <code>x-live</code>.</p> </p> <p>Example:</p> <pre><code>&lt;x-slot x-live={(p) =&gt; &lt;h2&gt;{p.title}&lt;/h2&gt;} title=\"My Component\" /&gt;\n</code></pre>"},{"location":"control-flow/portal/","title":"x-portal","text":"<p>x-portal</p> <p>Utility that enables portal rendering, allowing elements to be rendered outside the component's DOM.</p> <p>With <code>x-portal</code>, you can seamlessly render content into a specified target container, even if it exists outside the current component's hierarchy. This feature is particularly useful for implementing modals, overlays, or other UI elements that need to be rendered at a different location in the DOM. Simplify your component architecture and enhance flexibility with the convenience of <code>x-portal</code></p> <p>By using <code>x-fragment</code> in combination with <code>x-portal</code>, you can create a Document Fragment, a lightweight container that allows you to group multiple elements together without adding additional nodes to the DOM. This can be helpful when you need to render multiple elements as a single unit.</p> <p>Example (Component):</p> <p>Re-renders</p> <p>This re-renders! Replacing anything in the selected container.</p> <pre><code>&lt;x-slot x-portal=\"#modal\"&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/x-slot&gt;\n</code></pre> <p>Example (Fragment):</p> <p>Appends</p> <p>This appends to the selected container.</p> <pre><code>&lt;x-slot x-portal=\"#modal\" x-fragment&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/portal/#using-slot-instead","title":"Using <code>slot</code> instead.","text":"<pre><code>&lt;x-slot x-portal=\"#modal\" slot={&lt;h1&gt;Hello World&lt;h1&gt;}&gt;&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/show/","title":"x-show","text":"<p>x-show<p>Utility for enabling conditional display with CSS class manipulation.</p> <p>With <code>x-show</code>, you can easily control whether an element should be shown or hidden based on the truthiness of the provided condition. This feature allows you to apply CSS classes dynamically to toggle the element's visibility, resulting in a more interactive and responsive user interface.</p> </p> <p>Example:</p> <pre><code>function Component(props) {\nconst status = preact.useSignal(false);\nreturn (\n&lt;div x-html x-show=\"{status.value}\"&gt;\nHide and Seek\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"control-flow/switch/","title":"x-switch and x-case then case","text":"<p>x-switch | x-case | case<p>A powerful trio of utilities that allow you to conditionally render content based on a switch case.</p> <p>With <code>x-switch</code>, <code>x-case</code>, and <code>case</code>, you can easily handle different scenarios and render specific content for each case. This feature is particularly useful for creating dynamic views and managing conditional rendering in a more organized and concise manner. Simplify your component logic and enhance code readability with the versatility of <code>x-switch</code>, <code>x-case</code>, and <code>case</code>.</p> </p> <p>Example:</p> <pre><code>function View() {\nconst page = preact.useSignal(\"one\");\nreturn (\n{/* x-switch and x-case control structure */}\n&lt;x-slot x-switch x-case={page.value}&gt;\n{/* render case */}\n&lt;x-slot case=\"one\"&gt;Page One&lt;/x-slot&gt;\n&lt;x-slot case=\"two\"&gt;Page Two&lt;/x-slot&gt;\n&lt;x-slot case=\"three\"&gt;Page Three&lt;/x-slot&gt;\n&lt;/x-slot&gt;\n);\n}\n</code></pre>"},{"location":"directives/click-outside/","title":"x-click-outside","text":"<p>x-click-outside<p>Utility that actively listens for clicks outside the specified element and automatically triggers a callback function. With <code>x-click-outside</code>, you can effortlessly capture clicks occurring outside the element and respond with custom actions or behavior. This feature is particularly valuable for scenarios like closing pop-ups, modals, or dropdowns when users interact with elements outside of them.</p> </p> <p>Example:</p> <pre><code>&lt;div\nx-html\nx-click-outside={({ self }) =&gt; console.log(\"Clicked outside\")}\n&gt;&lt;/div&gt;\n</code></pre>"},{"location":"directives/hover/","title":"x-hover","text":"<p>x-hover<p>Designed to handle hover events with ease. Use <code>x-hover</code> to effortlessly manage interactions triggered by hovering over elements. This utility empowers you to define custom actions or styles when users hover over specific elements, enhancing the interactivity and visual feedback of your application.</p> </p> <p>Example:</p> <pre><code>&lt;div x-html x-hover={({ value }) =&gt; console.log(value)}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/ref/","title":"x-ref","text":"<p>x-ref</p> <p>A utility function designed for efficiently handling the <code>useRef()</code> value of the current <code>&lt;element-component&gt;</code>.</p> <p>With <code>x-ref</code>, you can easily access and interact with the current value of the referenced element component. This allows you to perform actions on the referenced element without triggering re-renders.</p> <p>Simplify your element management and optimize performance with <code>x-ref</code>.</p> Key Description <code>ref.add</code> Add class(es) to the DOM element <code>ref.remove</code> Remove class(es) to the DOM element <code>ref.toggle</code> Toggle class(es) to the DOM element <code>ref.contains</code> Check if DOM element Contains a class <code>ref.get</code> Run <code>querySelector</code> on DOM element <code>ref.find</code> Run <code>querySelectorAll</code> on DOM element <p>Example:</p> <pre><code>function Component(props) {\nlet ref = null;\nreturn (\n&lt;div x-ref={(self) =&gt; (ref = self)} x-html&gt;\nContent goes here...\n&lt;/div&gt;\n);\n}\n</code></pre> <p>Usage:</p> <pre><code>// Current\nref.current;\n// Utils\nref.add(\"class-after-init\");\nref.remove(\"class-after-init\");\nref.toggle([\"toggled-classes\"], true);\nref.contains(\"toggled-classes\");\n// Children Utils\nref.get(\".one-child\");\nref.find(\".all-children\");\n</code></pre>"},{"location":"directives/resize/","title":"x-resize","text":"<p>x-resize<p>Utility that effectively handles resize events with ease. With <code>x-resize</code>, you can effortlessly manage interactions triggered by resizing the window. This utility empowers you to define custom actions or styles when the element's size changes, providing a more responsive and adaptable user experience.</p> <p>Simplify event handling and optimize your application's behavior with the flexibility of <code>x-resize</code>.</p> </p> <p>Example:</p> <pre><code>&lt;div x-html x-resize={({ event }) =&gt; console.log(event)}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/ripple/","title":"x-ripple","text":"<p>x-ripple<p>A delightful utility that adds an elegant ripple effect to elements, enhancing visual feedback and interactivity. With <code>x-ripple</code>, you can effortlessly elevate the user experience by providing a subtle animation when elements are interacted with. Create a more engaging and polished interface with the power of <code>x-ripple</code>.</p> </p> <p>Example:</p> <pre><code>&lt;button x-html x-ripple&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/button&gt;\n</code></pre> <p>Config Example:</p> <pre><code>&lt;button\nx-html\nx-ripple={{\ncenter: true,\ncircle: true,\ncolor: \"red\",\nclass: \"my-class\",\n}}\n&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/button&gt;\n</code></pre>"},{"location":"directives/scroll/","title":"x-scroll","text":"<p>x-scroll</p> <p>Utility that facilitates handling scroll events and executing actions within the current element. With <code>x-scroll</code>, you can seamlessly manage scroll interactions and define custom behaviors when users scroll within the element.</p> <p>Enhance interactivity and user experiences by leveraging the power of <code>x-scroll</code> to create dynamic and engaging content.</p> <p>Example:</p> <pre><code>&lt;div\nx-html\nx-scroll={({ value, self }) =&gt; {\n/* ... */\nconsole.log(value);\nself.ref.toggle([\"they-see-me-scrolling\"]);\n}}\n&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/swipe/","title":"x-swipe","text":"<p>x-swipe<p>Utility that enables seamless detection of swipe gestures and emits the corresponding direction. With x-swipe, you can easily recognize and respond to swipe interactions, providing valuable input for navigating or triggering actions within your application. Enhance user experiences and simplify swipe gesture handling with the power of <code>x-swipe</code>.</p> </p> <p>Example:</p> <pre><code>&lt;div x-html x-swipe={({ value }) =&gt; console.log(\"side \" + value)}&gt;\nSwipe me\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/value/","title":"HTML Input","text":""},{"location":"directives/value/#attributes","title":"Attributes","text":"<ul> <li><code>x-input</code></li> <li><code>x-value</code></li> <li><code>x-value-clean</code></li> <li><code>x-value-disabled</code></li> <li><code>x-value-validators</code></li> </ul>"},{"location":"directives/value/#x-value","title":"x-value","text":"<p>x-value</p> <p>The <code>x-value</code> directive efficiently updates the value of a specified Preact <code>signal</code> based on the associated element's input type. When used with input elements (<code>input</code>, <code>textarea</code>, <code>select</code>, <code>progress</code>), <code>x-value</code> allows seamless synchronization between the element's value and the corresponding <code>signal</code>, ensuring your application remains in sync with user input. This simplifies state management and enhances data flow within your application.</p> <pre><code>function Component(props) {\nconst text = preact.useSignal(\"\");\nreturn &lt;input x-html x-value={text} /&gt;;\n}\n</code></pre>"},{"location":"directives/value/#x-value-clean","title":"x-value-clean","text":"<p>x-value-clean</p> <p>The <code>x-value-clean</code> directive allows you to clean or filter the input value before updating the state and the element's value. This can be useful for normalizing input data, such as trimming whitespace or converting to a specific case.</p> <pre><code>function Component(props) {\nconst text = preact.useSignal(\"\");\nreturn (\n&lt;input\nx-html\nx-value={text}\nx-value-clean={(value) =&gt; value.toLowerCase()}\n/&gt;\n);\n}\n</code></pre>"},{"location":"directives/value/#x-value-validators","title":"x-value-validators","text":"<p>x-value-validators</p> <p>The <code>x-value-validators</code> directive provides a way to validate the input value after it has been cleaned. You can define an array of validation functions that each return either <code>true</code> for a valid value or a string describing the validation error.</p> <pre><code>function Component(props) {\nconst text = preact.useSignal(\"\");\nreturn (\n&lt;input\nx-html\nx-value={text}\nx-value-validators={[\n(v) =&gt; !!v || \"Required Field!\",\n(v) =&gt; v.length &gt;= 8 || \"At least 8 characters long\",\n]}\n/&gt;\n);\n}\n</code></pre>"},{"location":"directives/value/#x-value-disabled","title":"x-value-disabled","text":"<p>x-value-disabled</p> <p>The <code>x-value-disabled</code> directive is useful for disabling the input from user interaction. This can be used to conditionally enable or disable input elements based on application state.</p> <pre><code>function Component(props) {\nreturn &lt;input x-html x-value-disabled /&gt;;\n}\n</code></pre>"},{"location":"directives/value/#x-input","title":"x-input","text":"<p>x-input</p> <p>The <code>x-input</code> directive is useful for extending an input component. It allows you to:</p> <ul> <li>Get the current <code>value</code> of the input</li> <li>Submit the input value if it is <code>valid</code></li> <li>Present <code>errors</code> to the client for invalid inputs</li> </ul> <pre><code>function Component(props) {\nconst text = preact.useSignal(\"\");\nreturn (\n&lt;input\nx-html\nx-input={({ value, valid, errors }) =&gt;\nconsole.log({ value, valid, errors })\n}\n/&gt;\n);\n}\n</code></pre>"},{"location":"directives/value/#example","title":"Example","text":"<pre><code>function Component(props) {\nconst text = preact.useSignal(\"\");\nreturn (\n&lt;input\nx-html\nx-input={({ value, valid, errors }) =&gt;\nconsole.log({ value, valid, errors })\n}\nx-value={text}\nx-value-clean={(value) =&gt; value.toLowerCase()}\nx-value-validators={[\n(v) =&gt; !!v || \"Required Field!\",\n(v) =&gt; v.length &gt;= 8 || \"At least 8 characters long\",\n]}\n/&gt;\n);\n}\n</code></pre>"},{"location":"plugins/","title":"Install","text":"<p>The <code>install</code> method is where you setup your plugin. It receives the <code>self</code> (module) and <code>options</code> (configuration) as parameters.</p> <p>You can customize the plugin by adding various parts within the returned object. Such as...</p> <ul> <li><code>init</code></li> <li><code>actions</code></li> <li><code>directives</code></li> <li><code>globals</code></li> <li><code>models</code></li> <li><code>router</code></li> <li><code>store</code></li> </ul> <pre><code>const Plugin = {\n/**\n   * Plugin Install\n   * @param {Object} self - The plugin instance.\n   * @param {Object} options - Configuration options for the plugin.\n   * @returns {Object} - Various plugin parts (actions, directives, etc).\n   */\ninstall(self, options) {\nconsole.log(\"The Plugin\", self);\nconsole.log(\"The Options\", options);\n/* Plugin Parts */\nreturn {\nactions: {},\ndirectives: {},\nglobals: {},\ninit: {},\nmodels: {},\nrouter: {},\nstore: {},\n};\n},\n};\n</code></pre>"},{"location":"plugins/#use-your-plugin","title":"<code>Use</code> your plugin","text":"<p>To use your plugin, simply call <code>xtyle.use</code>. This will execute the install method and set up your plugin.</p> <pre><code>xtyle.use(Plugin, { key: \"value\" }); // This will run the `install` method.\n</code></pre>"},{"location":"plugins/actions/","title":"Actions","text":"<p>Global <code>actions</code> allow you to manage actions that are used across your entire application.</p> <p>Arguments</p> <p>Functions can be executed with or without arguments.</p>"},{"location":"plugins/actions/#example-setup","title":"Example Setup","text":"<p>The following example demonstrates how to set up a plugin with a global action.</p> <pre><code>/* Plugin Install */\nexport function install(self, option) {\nreturn {\nactions: {\napi: {\ndemo(args) {\nconsole.log(\"Global Actions\");\n},\n},\n},\n};\n}\n</code></pre>"},{"location":"plugins/actions/#running-actions","title":"Running Actions","text":"<p>To run a global action, use the <code>xtyle.action</code> method. The following example shows how to execute the <code>demo</code> action with an argument.</p> <pre><code>xtyle.action(\"api.demo\", { param: 1 });\n</code></pre>"},{"location":"plugins/directives/","title":"Directives","text":"<p>Directives are special attributes that interact with the DOM, enabling you to apply side effects or modifications to elements. They provide a powerful way to extend the functionality of your components by encapsulating reusable behaviors.</p>"},{"location":"plugins/directives/#custom-directives","title":"Custom Directives","text":"<p>Custom <code>directives</code> start with the prefix <code>x-</code>. For example, the <code>extraclass</code> directive can be declared and used to add additional classes to an element.</p>"},{"location":"plugins/directives/#declaring-a-custom-directive","title":"Declaring a Custom Directive","text":"<p>Custom directives are defined within the <code>self.directives.custom</code> object. Here is how you can declare the <code>extraclass</code> directive:</p> <pre><code>/* Plugin Install */\nexport function install(self, option) {\nreturn {\n// ...\ndirectives: {\nextraclass(self, props) {\nconst { extraclass } = self.directives.custom;\nprops.class = [props.class, extraclass];\n},\n},\n// ...\n};\n}\n</code></pre>"},{"location":"plugins/directives/#using-a-custom-directive","title":"Using a Custom Directive","text":"<p>Once declared, you can use your custom directive in your components by adding the <code>x-</code> prefix to the directive name. Here\u2019s an example of using the <code>extraclass</code> directive:</p> <pre><code>&lt;div x-extraclass=\"directive\" class=\"regular\"&gt;&lt;/div&gt;\n</code></pre> <p>In this example, the <code>extraclass</code> directive adds additional classes to the element based on the logic defined in the directive.</p>"},{"location":"plugins/directives/#example-explanation","title":"Example Explanation","text":"<ul> <li>Declaration: The directive is defined within the <code>directives</code> object in the <code>install</code> function.</li> <li>Usage: The directive is applied to an element using the <code>x-extraclass</code> attribute.</li> </ul> <p>This setup allows you to encapsulate and reuse custom behaviors across your application, enhancing modularity and maintainability.</p>"},{"location":"plugins/globals/","title":"Globals","text":"<p>Declaring <code>globals</code> variables allows you to define variables that can be reused throughout your entire application. This helps in maintaining consistency and reducing redundancy by providing a single source of truth for commonly used values. Unlike store variables, global variables are not reactive, meaning their changes won't automatically trigger updates in the UI or other parts of your application.</p>"},{"location":"plugins/globals/#example-setup","title":"Example Setup","text":"<p>Here\u2019s how you can define and use a global variable in your application.</p>"},{"location":"plugins/globals/#defining-a-global-variable","title":"Defining a Global Variable","text":"<pre><code>/* Plugin Install */\nexport function install(self, option) {\nreturn {\n// ...\nglobals: {\nsomeVariable: \"Hello World!\",\n},\n// ...\n};\n}\n</code></pre>"},{"location":"plugins/globals/#accessing-a-global-variable","title":"Accessing a Global Variable","text":"<p>You can access the value of a global variable directly through the <code>xtyle.global</code> object.</p> <pre><code>console.log(xtyle.global.someVariable);\n</code></pre> <p>Using <code>globals</code> variables ensures that your application's commonly used values are centralized and easy to manage, promoting consistency and reducing the risk of discrepancies.</p>"},{"location":"plugins/init/","title":"INIT","text":"<p>The <code>init</code> section is automatically called when starting your application. Its purpose is to perform any other necessary setup, both <code>before</code> and <code>after</code> the instance is fully created. This ensures that all necessary configurations and preparations are completed, providing a stable starting state for your application.</p> <pre><code>/* Plugin Install */\nexport function install(self, option) {\nreturn {\n// ...\ninit: {\nbefore: [() =&gt; console.log(`Before Init`)],\nafter: [() =&gt; console.log(`After Init`)],\n},\n// ...\n};\n}\n</code></pre>"},{"location":"plugins/models/","title":"Models","text":"<p>Models can be declared in two ways: using an array of keys or using an object with key-value pairs to set default values.</p> <p>The <code>$root: true</code> option creates models in the group without a namespace. By default, models are grouped into namespaces to organize them and avoid naming conflicts.</p> <p>Fields</p> <p>The fields you declare in the object are designed to be reactive. For example, you might declare fields such as <code>[\"firstName\", \"lastName\"]</code> because they will receive input from the user. You don't need to declare a field like <code>fullName</code>, as it can be computed dynamically from <code>firstName</code> and <code>lastName</code>. This approach allows the constructor to identify which fields require input handling and ensures that only necessary fields are explicitly created for input operations.</p> <pre><code>/* Plugin Install */\nexport function install(self, option) {\nreturn {\n// ...\nmodels: {\n// $root: true\ncoreModels: {\n$root: true, // Makes it a root model, without a namespace.\nmodelOne: [\"fieldName\"],\nmodelTwo: [\"fieldName\"],\n},\n// namespaced models\nnamespace: {\nmodelOne: { fieldName: \"value\" },\nmodelTwo: { fieldName: \"value\" },\n},\n// Database Real Names\n$ref: {\nmodelOne: \"database_table_one\",\n\"namespace.modelOne\": \"database_table_two\",\n},\n},\n// ...\n};\n}\n</code></pre> <p>$ref</p> <p>To associate your model with the name of the backend, you can use the <code>$ref</code> attribute. This allows you to specify the backend reference for your model, ensuring that it correctly corresponds to the backend's data structure or endpoint.</p>"},{"location":"plugins/models/#get-model","title":"Get Model","text":"<pre><code>// $root: true\nconst coreModel = xtyle.models.get(\"modelOne\");\n// namespaced model\nconst namespaceModel = xtyle.models.get(\"namespace.modelOne\");\n</code></pre>"},{"location":"plugins/models/#list-all-models","title":"List All Models","text":"<pre><code>console.log(xtyle.models.keys());\n</code></pre>"},{"location":"plugins/models/#model-objects","title":"Model <code>objects</code>","text":"<pre><code>const { objects } = xtyle.models.get(\"namespace.modelOne\");\nconsole.log(objects.value);\n</code></pre>"},{"location":"plugins/models/#loading-objects","title":"Loading Objects","text":"<pre><code>const { objects } = xtyle.models.get(\"namespace.modelOne\");\n// Load Data\nobjects.value = [{ id: 1, firstName: \"john\", lastName: \"doe\" }];\n</code></pre>"},{"location":"plugins/models/#model-instance","title":"Model <code>instance</code>","text":"<pre><code>const { instance } = xtyle.models.get(\"namespace.modelOne\");\n// Access a field in the instance\nconsole.log(instance.fieldName.value);\n</code></pre>"},{"location":"plugins/models/#core-utility-methods","title":"Core Utility Methods","text":"Key Description <code>$set</code> Sets new values in the dictionary <code>$reset</code> Resets all values in the dictionary <code>$diff</code> Computes the difference between original &amp; current <code>$</code> Computed values"},{"location":"plugins/models/#other-utility-methods","title":"Other Utility Methods","text":"Key Description <code>$keys</code> Iterates over each key in the dictionary <code>$computed</code> Uses a computed value based on context <code>$effect</code> Applies a side effect based on context <code>$get</code> Retrieves a value from the dictionary <code>$items</code> Gets all key-value pairs from the dictionary <code>$for</code> Iterates over each item in the dictionary <code>$values</code> Iterates over each value in the dictionary"},{"location":"plugins/models/#loading-an-instance","title":"Loading an Instance","text":"<p>This how you load the instance from the backend.</p> <pre><code>const { instance } = xtyle.models.get(\"namespace.modelOne\");\n// Load Data\ninstance.$set({\nfirstName: \"john\",\nlastName: \"doe\",\n});\n</code></pre>"},{"location":"plugins/models/#updating-an-instance-locally","title":"Updating an Instance Locally","text":"<pre><code>const { instance } = xtyle.models.get(\"namespace.modelOne\");\n// Update a Field\ninstance.firstName.value = \"katarina\";\n</code></pre>"},{"location":"plugins/models/#commit-instance-updates","title":"Commit Instance Updates","text":"<p>The <code>$diff</code> will return only the fields that have changed.</p> <pre><code>const { instance } = xtyle.models.get(\"namespace.modelOne\");\n// Get Difference and Saving Method\nconst { value, save } = instance.$diff();\n// Backend Commit Updates\nsomeBackendAPIUpdate(value).then(() =&gt; {\n// Save Updates Locally\nsave();\n});\n</code></pre>"},{"location":"plugins/router/","title":"Router","text":"<p>The <code>router</code> section is dedicated to configuring routing behaviors within your application. This encompasses defining rules for redirection when a user attempts to access a view they are not authorized to see, as well as loading data before presenting the page to the user.</p> <pre><code>/* Plugin Install */\nexport function install(self, option) {\nreturn {\n// ...\nrouter: {\nbefore({ commit, redirect, prev, next }) {\n// Commits Change\ncommit();\n// OR\n// Redirect\nredirect(\"/login\");\n},\nafter({ prev, next }) {\n// (Info) Prev &amp; Next\nconsole.log(prev);\nconsole.log(next);\n},\n},\n// ...\n};\n}\n</code></pre>"},{"location":"plugins/router/#dynamic-path-patterns","title":"Dynamic Path Patterns","text":"<p>When defining routes, you can use dynamic path patterns to handle different scenarios:</p> <ul> <li><code>/{variable}</code>: Encapsulating a word with <code>{}</code> brackets makes it a required path parameter.</li> <li><code>/{?variable}</code>: The <code>?</code> at the start indicates that the parameter is optional.</li> <li><code>/{variable*}</code>: The <code>*</code> at the end denotes a wildcard parameter, which matches the remaining part of the path.</li> </ul>"},{"location":"plugins/router/#configuration-example","title":"Configuration (Example)","text":"<p>Here's an example of how to initialize the router and configure it with options and route patterns:</p> <p>Path Patterns (Examples)</p> <ul> <li> <p><code>/a/some-{key}</code> : This one is required!</p> </li> <li> <p><code>/a/b-{?key}</code> : The \"<code>?</code>\" indicates that the parameter <code>key</code> is optional.</p> </li> <li> <p><code>/a/b/{path*}</code> : The \"<code>*</code>\" denotes a wildcard parameter named <code>path</code>, which matches the remaining part of the path.</p> </li> </ul>"},{"location":"plugins/router/#register-a-view","title":"Register a View","text":"<pre><code>const View = ({ route, search, arg }) =&gt; {\nreturn h(\"h1\", null, \"My View\");\n};\nxtyle.view(\"/some-page-name\", View);\n</code></pre>"},{"location":"plugins/router/#display-views","title":"Display Views","text":"<pre><code>&lt;xtyle.router.views /&gt;\n</code></pre>"},{"location":"plugins/router/#change-routes-aka-views","title":"Change Routes (aka: Views)","text":"<pre><code>// No Parameters\nxtyle.router.go(\"/some-page\");\n// With Parameters\nxtyle.router.go(\"/some-page\", { search: \"something\" });\n</code></pre>"},{"location":"plugins/router/#utils-xtylerouter","title":"Utils <code>xtyle.router</code>","text":"<p>The <code>xtyle.router</code> utility provides various methods to manage routing within your application, ensuring smooth navigation and view handling.</p> Key Description <code>go</code> Navigates to a specified route or view. <code>views</code> Returns a component of the current view in the application. <code>current</code> Retrieves information about the current view or route."},{"location":"plugins/router/#utils-xtyleroutercurrent","title":"Utils <code>xtyle.router.current</code>","text":"<p>The <code>xtyle.router.current</code> utility offers detailed information about the currently active route, providing insights into the current view and its parameters.</p> Key Description <code>view</code> The current view as a function. <code>arg</code> URL parameters of the current path. For example <code>/{argOne}/{argTwo}</code> <code>path</code> The full path of the current route. <code>search</code> URL search parameters of the route. For example <code>/?arg=1&amp;param=2</code> <code>route</code> The name or identifier of the current view."},{"location":"plugins/store/","title":"Store","text":"<p>The <code>store</code> section enables you to create centralized variables known as store variables, which are accessible throughout the entire application. This provides a single, organized location for managing and accessing important data, ensuring consistency and ease of reference.</p>"},{"location":"plugins/store/#store-vs-globals","title":"Store vs. Globals","text":"<p>The main difference between <code>globals</code> and <code>store</code> is that store variables are designed to be reactive, while global variables are not. Reactive store variables automatically update the UI or trigger other actions whenever their values change.</p>"},{"location":"plugins/store/#example-setup","title":"Example Setup","text":"<p>Here\u2019s how you can define and use a store variable in your application.</p>"},{"location":"plugins/store/#defining-a-store-variable","title":"Defining a Store Variable","text":"<pre><code>const { signal } = preact;\n/* Plugin Install */\nexport function install(self, option) {\nreturn {\n// ...\nstore: {\ndarkMode: signal(true),\n},\n// ...\n};\n}\n</code></pre>"},{"location":"plugins/store/#accessing-a-store-variable","title":"Accessing a Store Variable","text":"<p>You can access the value of a store variable using the <code>.value</code> property.</p> <pre><code>console.log(xtyle.store.darkMode.value);\n</code></pre>"},{"location":"plugins/store/#updating-a-store-variable","title":"Updating a Store Variable","text":"<p>Since store variables are reactive, updating them will automatically reflect the changes wherever they are used in your application.</p> <pre><code>xtyle.store.darkMode.value = false;\n</code></pre> <p>Using <code>store</code> ensures that your application's state management is centralized, consistent, and reactive, making it easier to maintain and scale.</p>"},{"location":"tools/api/","title":"(API) Application Programming Interface","text":"<p>The <code>xtyle.api</code> function simplifies making HTTP requests to a specified base URL with customizable options. This documentation provides an overview of how to set up the API client and make GET, POST, and file upload requests.</p>"},{"location":"tools/api/#setup","title":"Setup","text":""},{"location":"tools/api/#import-and-initialize","title":"Import and Initialize","text":"<pre><code>const baseURL = \"https://example.com\";\nconst options = {\nheaders: {\nAuthorization: \"Bearer YOUR_ACCESS_TOKEN\",\n},\n};\nconst api = xtyle.api(baseURL, options);\n</code></pre> <ul> <li><code>baseURL</code>: The base URL for the API.</li> <li><code>options</code>: An object containing configuration options, such as headers.</li> </ul>"},{"location":"tools/api/#making-requests","title":"Making Requests","text":""},{"location":"tools/api/#get-request","title":"GET Request","text":"<pre><code>api\n.get(\"path\", { param1: \"value1\", param2: \"value2\" })\n.then((data) =&gt; console.log(\"GET response:\", data))\n.catch((error) =&gt; console.error(\"GET error:\", error));\n</code></pre> <ul> <li><code>path</code>: The endpoint path relative to the base URL.</li> <li><code>params</code>: An object containing query parameters.</li> </ul>"},{"location":"tools/api/#post-request","title":"POST Request","text":"<pre><code>api\n.post(\"path\", { key1: \"value1\", key2: \"value2\" })\n.then((data) =&gt; console.log(\"POST response:\", data))\n.catch((error) =&gt; console.error(\"POST error:\", error));\n</code></pre> <ul> <li><code>path</code>: The endpoint path relative to the base URL.</li> <li><code>body</code>: An object containing the request payload.</li> </ul>"},{"location":"tools/api/#file-upload","title":"File Upload","text":""},{"location":"tools/api/#single-file-upload","title":"Single File Upload","text":"<pre><code>const fileInput = document.getElementById('fileInput') as HTMLInputElement;\napi\n.upload(\"upload\", fileInput.files[0])\n.then((data) =&gt; console.log(\"File Upload response:\", data))\n.catch((error) =&gt; console.error(\"File Upload error:\", error));\n</code></pre> <ul> <li><code>path</code>: The endpoint path relative to the base URL.</li> <li><code>file</code>: A single file to be uploaded.</li> </ul>"},{"location":"tools/api/#multiple-files-upload","title":"Multiple Files Upload","text":"<pre><code>const multipleFiles = [fileInput.files[0], fileInput.files[1]];\napi\n.upload(\"upload\", multipleFiles)\n.then((data) =&gt; console.log(\"Files Upload response:\", data))\n.catch((error) =&gt; console.error(\"Files Upload error:\", error));\n</code></pre> <ul> <li><code>path</code>: The endpoint path relative to the base URL.</li> <li><code>files</code>: An array of files to be uploaded.</li> </ul>"},{"location":"tools/api/#error-handling","title":"Error Handling","text":"<p>Each request method returns a promise that can be handled using <code>.then()</code> for successful responses and <code>.catch()</code> for handling errors.</p>"},{"location":"tools/api/#example","title":"Example","text":"<pre><code>api\n.get(\"example\", { sample: \"data\" })\n.then((response) =&gt; {\nconsole.log(\"Response received:\", response);\n})\n.catch((error) =&gt; {\nconsole.error(\"Error occurred:\", error);\n});\n</code></pre> <p>This setup provides a consistent and straightforward way to interact with your API, handling various types of requests with ease.</p>"},{"location":"tools/device/","title":"Device","text":"<p>The Device section provides utilities for accessing the dimensions of the window, allowing you to dynamically respond to changes in window size within your application.</p>"},{"location":"tools/device/#window-width-x","title":"Window Width (<code>X</code>)","text":"<p>Access the current width of the window.</p> <pre><code>xtyle.device.x;\n</code></pre>"},{"location":"tools/device/#window-height-y","title":"Window Height (<code>Y</code>)","text":"<p>Access the current height of the window.</p> <pre><code>xtyle.device.y;\n</code></pre>"},{"location":"tools/device/#size-classification-size","title":"Size Classification (<code>size</code>)","text":"<p>The current size classification of the window ('xs', 'sm', 'md', 'lg', 'xl').</p> <pre><code>xtyle.device.size;\n</code></pre>"},{"location":"tools/device/#is-mobile-mobile","title":"Is Mobile (<code>mobile</code>)","text":"<p>Indicates if the device is considered mobile based on the width. If the classification includes ('xs', 'sm', 'md')</p> <pre><code>xtyle.device.mobile;\n</code></pre>"},{"location":"tools/device/#is-specified-classification-is","title":"Is Specified Classification (<code>is</code>)","text":"<p>A function to check if the current size matches the specified classification. Takes a size classification ('xs', 'sm', 'md', 'lg', 'xl') as an argument.</p> <pre><code>xtyle.device.is(\"xs\", \"sm\") ? \"yes\" : \"no\";\n</code></pre>"},{"location":"tools/i18n/","title":"i18n","text":"<p>xtyle.i18n</p> <p>The i18n (internationalization) allows you to handle translations in your project effectively. With <code>xtyle.translations</code>, you can register translation object, and later, you can access those translations using <code>xtyle.i18n</code>.</p>"},{"location":"tools/i18n/#register-translations","title":"Register Translations","text":"<p>To set up translations, you need to use the <code>xtyle.translations</code> method. It takes an object as input.</p> <pre><code>/* Set Translations */\nxtyle.translations({\nfr: {\ngreetings: {\nhello: \"Bonjour!\",\n},\n},\n});\n</code></pre> <p>In this example, we're registering a single translation for the French language. You can add more translations for different languages by extending the <code>xtyle.translations</code> object with additional language codes and their respective translations.</p>"},{"location":"tools/i18n/#access-translations","title":"Access Translations","text":"<p>The <code>xtyle.i18n</code> method takes a single argument, which is a dot-separated string representing the path to the translation you want to retrieve.</p> <p>The format of the string is <code>path_to.translation_key</code>.</p> <p>Here's an example of how to use <code>xtyle.i18n</code> to retrieve the French greeting we registered earlier:</p> <pre><code>/* Preview */\nconsole.log(\"i18n: \", xtyle.i18n(\"fr.greetings.hello\"));\n</code></pre> <p>In this case, the output will be:</p> <pre><code>i18n: Bonjour!\n</code></pre> <p>By using <code>xtyle.i18n</code>, you can easily access the translations you registered globally throughout your project and display content in different languages based on the user's preference or the context of your application.</p>"},{"location":"tools/others/","title":"Others","text":"<p>A collection of utility functions designed to simplify common tasks in your application.</p>"},{"location":"tools/others/#string-to-xtylestringto","title":"String To <code>xtyle.stringTo</code>","text":"<p>The <code>xtyle.stringTo.&lt;method&gt;</code> utility provides various methods for converting and manipulating strings into different formats.</p> Method Description <code>camel</code> Converts a string to camel case. <code>slug</code> Converts a string to a slug. <code>lower</code> Converts a string to lowercase. <code>upper</code> Converts a string to uppercase. <code>title</code> Converts a string to title case. <code>pascal</code> Converts a string to pascal case. <code>docs</code> Converts a string to documentation format. <code>snake</code> Converts a string to snake case. <code>slot</code> Converts a string from kebab to pascal case. <code>cut</code> Trims a string to a specified length."},{"location":"tools/others/#general-utilities-xtyleutil","title":"General Utilities <code>xtyle.util</code>","text":"<p>The <code>xtyle.util.&lt;method&gt;</code> utility provides a variety of methods for different common tasks in your application.</p> Method Description <code>inject</code> Injects replaceable CSS into the document. <code>form</code> Converts an object into a form data structure. <code>timer</code> Converts years, months, days, hours, minutes, and seconds into milliseconds <code>props</code> Transforms an object's keys to camelCase."}]}