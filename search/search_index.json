{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Xtyle Library for (Preact)","text":"<p>Xtyle</p> <p>Welcome to Xtyle! Your Ultimate Directive Extension!   Enabling you to effortlessly extend your functions as global directives. Say goodbye to exporting and importing components constantly. Any <code>method</code> or <code>component</code> you register globally will be readily available throughout your whole Application.</p> <p><p>      Download (TypeScript) Template    </p> </p> <p>no-installation</p> <pre><code>&lt;script src=\"https://unpkg.com/xtyle@latest\" type=\"text/javascript\"&gt;&lt;/script&gt;\n</code></pre>"},{"location":"#description","title":"Description","text":"<p>Purpose and Goals</p> <p>The purpose of the <code>xtyle</code> tool is to revolutionize the way you develop for the browser. Our aim is to simplify the development process while maintaining compatibility with TypeScript and modern tools like VS Code. Xtyle empowers API developers by providing them with a simpler way to connect various plugins built with TypeScript/Javascript with their corresponding APIs.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Global Directives: Easily extend the behavior of your elements by declaring custom directives.</li> <li>Simplified Components: Define custom elements without the hassle of constant exporting and importing.</li> <li>Global Variables: Specify global variables that are accessible within your application's scope.</li> <li>Reactive State Management: Define global state variables that can be used reactively within your application.</li> </ul> <p>Plugins</p> <p>With <code>xtyle.use</code>, you can easily . . .</p> <ol> <li>Define Routes: Configure your route patterns using the <code>routes</code> prop to create a structured navigation flow.</li> <li>Declare Directives: Extend the behavior of your elements by declaring custom directives using the <code>directives</code> prop.</li> <li>Create Custom Elements: Define the custom elements you want to create with your plugin using the <code>elements</code> prop.</li> <li>Set Global Variables: Specify global variables within your plugin's scope using the <code>globals</code> prop.</li> <li>Reactive State Management: Define global state variables using the <code>store</code> prop to enable reactive updates.</li> </ol>"},{"location":"#core-api","title":"Core API","text":"Key Description <code>xtyle.init</code> Run Application <code>xtyle.use</code> Plugin(s) <code>xtyle.element</code> Component(s) <code>xtyle.directive</code> Directive(s) <code>xtyle.router</code> Router <code>xtyle.model</code> Model(s) <code>xtyle.base</code> Only useful with <code>TypeScript</code>"},{"location":"#x-html-directive","title":"<code>x-html</code> (Directive)","text":"<p>x-html</p> <p>Converts a regular HTML element into an Xtyle <code>&lt;Component /&gt;</code>.</p> <p>Example:</p> <pre><code>&lt;div x-html&gt;Regular div becomes a (Xtyle) Component&lt;/div&gt;\n</code></pre>"},{"location":"#x-slot-component","title":"<code>x-slot</code> (Component)","text":"<p>x-slot</p> <p>Converts a regular HTML element into an Xtyle <code>&lt;Fragment /&gt;</code>.</p> <p>Example:</p> <pre><code>&lt;x-slot&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"#creating-directives","title":"Creating Directives","text":"<p>custom &lt;div x-custom&gt;</p> <p>Registered directives will be enforced to be lower-case. Any directive you register under any given name will be prefixed with \u201c<code>x-</code>\u201d</p> <ul> <li><code>props</code> Arguments for the final Component.</li> <li><code>self</code> Arguments that construct the Component.</li> </ul> Key Description <code>self.directives.custom</code> Object where you can find your custom directive <code>self.ref.add</code> Add class(es) to the DOM element <code>self.ref.remove</code> Remove class(es) to the DOM element <code>self.ref.toggle</code> Toggle class(es) to the DOM element <code>self.ref.contains</code> Check if DOM element Contains a class <p>Example:</p> <pre><code>// \"x-demo\"\nxtyle.directive(\"demo\")((self, props) =&gt; {\npreact.useEffect(() =&gt; {\n// Self\nself.ref.add(\"class-after-init\");\nself.ref.remove(\"class-after-init\");\nself.ref.toggle([\"toggled-class\"], true);\nself.ref.contains(\"toggled-class\");\n}, []);\n// Demo\nconsole.log(\"Custom Directive\");\nconsole.log(self.directives.custom[\"demo\"]);\nconsole.log(props);\n});\n</code></pre> <p>Usage:</p> <p>\u201c<code>x-</code>\u201d Prefix</p> <pre><code>&lt;div x-demo=\"Hello World\" x-html&gt;&lt;/div&gt;\n</code></pre> <p>Directives</p> <p>Directives are a powerful tool that allows developers to reuse and encapsulate logic in their code. By leveraging custom directives, developers can effectively separate and encapsulate complex logic and low-level DOM operations, resulting in more modular and maintainable code. These directives enable the reuse of specific functionalities across multiple elements or components, promoting code consistency and reducing duplication.</p> <p>Custom directives provide a flexible and reusable approach to address unique requirements in web development. They can be used for a variety of purposes, such as applying specialized behaviors, manipulating the DOM, or implementing custom event handling. With custom directives, developers have the ability to create highly adaptable and reusable solutions that cater to specific needs.</p>"},{"location":"#creating-components","title":"Creating Components","text":"<p>custom &lt;x-component&gt;</p> <p>Registered components will be enforced to be lower-case and kebab-case. Any component you register under any given name will be prefixed with \u201c<code>x-</code>\u201d</p> <p>Example:</p> <p>A custom component that displays a title and its children.</p> <pre><code>xtyle.element(\"demo\")((props) =&gt; (\n&lt;x-slot&gt;\n&lt;h2&gt;{props.title}&lt;/h2&gt;\n{props.children}\n&lt;/x-slot&gt;\n));\n</code></pre> <p>Usage:</p> <ul> <li><code>title</code>: The title for the component.</li> </ul> <pre><code>&lt;x-demo title=\"Hello World\"&gt;\n&lt;h4&gt;Content goes here...&lt;/h4&gt;\n&lt;/x-demo&gt;\n</code></pre>"},{"location":"#creating-plugins","title":"Creating Plugins","text":"<p>xtyle.use</p> <p>Simplifying Plugin Registration:</p> <p>The <code>xtyle.use</code> function is a powerful utility that simplifies the process of registering various <code>elements</code>, <code>directives</code>, <code>globals</code>, and <code>store</code> in a single place for your plugin. This documentation will guide you through the steps to create and register your plugins effectively.</p>"},{"location":"#props","title":"Props:","text":"<ul> <li><code>routes</code>: Define your route(s) pattern(s).</li> <li><code>directives</code>: Declare custom directives to extend the behavior of your elements.</li> <li><code>elements</code>: Define the custom elements you want to create with your plugin.</li> <li><code>globals</code>: Specify global variables accessible within your plugin's scope.</li> <li><code>store</code>: Define global state variables that can be used reactively within your plugin.</li> </ul>"},{"location":"#example","title":"Example:","text":"<p>Below is an example of how to create and register a custom plugin using <code>xtyle.use</code>:</p> <pre><code>const myPlugin = {\n/** @Routes */\nroutes: [\"/my-app/\", \"/my-app/{path*}\"],\n/** @Directives */\ndirectives: {\nhtml(self, props) {\n// Logic to handle the 'html' directive\n// ...\n},\n},\n/** @Elements */\nelements: {\nbutton(props) {\nreturn &lt;button&gt;Click Me | {props.children}&lt;/button&gt;;\n},\n},\n/** @Globals */\nglobals: {\ntitle: \"Xtyle Project\",\n},\n/** @Store */\nstore: {\ncount: xtyle.signal(0),\n},\n};\n// Register the plugin\nxtyle.use(myPlugin);\n</code></pre> <p>By following this example, you've successfully created a plugin that includes:</p> <ul> <li>a custom <code>x-html</code> directive.</li> <li>a <code>x-button</code> element.</li> <li>a <code>title</code> global variable.</li> <li>a <code>count</code> store global state.</li> </ul> <p>These can now be used within your application.</p> <pre><code>// App (Demo)\nconst App = () =&gt; (\n&lt;div x-html&gt;\nCount is: {xtyle.store.count}\n&lt;x-button&gt;{xtyle.global.title}&lt;/x-button&gt;\n&lt;/div&gt;\n);\n// Reactive Count\nsetInterval(() =&gt; {\nxtyle.store.count.value += 1;\n}, 1000);\n// Render the App\npreact.render(preact.h(App), document.body);\n</code></pre> <p>Warning</p> <p>The <code>x-html</code> directive is a built-in directive.</p>"},{"location":"#init-run-application","title":"INIT Run Application","text":"<pre><code>import myPlugin from \"./plugin.ts\";\nimport Main from \"./main.tsx\";\n/**\n * @Register &lt;Plugin&gt;\n */\nxtyle.use(myPlugin);\n/**\n * @Router\n */\nconst router = {\nhistory: false,\nbaseURL: null,\n};\n/**\n * @Render\n */\nxtyle.init(Main, document.body, router);\n</code></pre>"},{"location":"#main-properties","title":"Main Properties","text":"Key Description <code>xtyle.global</code> Object where you can find your custom directive <code>xtyle.store</code> Object where you can find your custom directive <code>xtyle.router</code> Object where you can find your custom directive"},{"location":"#app-preview-variables","title":"(App) Preview Variables","text":"<pre><code>/* Globals */\nconsole.log(\"Globals: \", xtyle.global);\n/* Store */\nconsole.log(\"Store: \", xtyle.store);\n/* Routes Keys */\nconsole.log(\"Routes: \", Object.keys(xtyle.router.routes));\n/* Directives Keys */\nconsole.log(\"Directives: \", Object.keys(xtyle.allDirectives));\n/* Components Keys */\nconsole.log(\"Components: \", Object.keys(xtyle.allComponents));\n</code></pre>"},{"location":"css/","title":"Reactive CSS","text":"<p>Reactive CSS</p> <p>A powerful CSS solution that dynamically applies styles based on the state of an element <code>(is)</code>, distinguishing between <code>(on)</code> active and <code>(off)</code> inactive control conditions. The advantage lies in its ability to update styles without requiring a full re-rendering of the element. This approach provides a seamless and efficient way to manage element styles based on user interactions or changing states, resulting in a more responsive and interactive user experience.</p> Directive Description css-is Specifies the CSS class to apply when the condition is <code>true</code>. css-on Specifies the CSS classes to add when the condition is <code>true</code>. css-off Specifies the CSS classes to add when the condition is <code>false</code>. <p>Example:</p> <pre><code>function Component(props) {\nconst status = preact.useSignal(false);\nreturn (\n&lt;div x-html css-is={status.value} css-on=\"active\" css-off=\"inactive\"&gt;\nContent goes here...\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"hooks/","title":"Hooks","text":"<p>hook-{ method }<p>Hooks empower you to efficiently reuse stateful logic across multiple components. With hooks, you can extract and manage complex functionalities, such as managing component state, performing side effects, and handling lifecycle events, all in a modular and reusable manner. This promotes code organization and reduces code duplication, enabling you to build more maintainable and scalable applications.</p> </p> Directive Description hook-created Hook called when the component is created. hook-updated Hook called when the component is updated. hook-removed Hook called when the component is removed from the DOM. <p>Example:</p> <pre><code>&lt;div\n  x-html\n  hook-created={() =&gt; console.log(\"Component &lt;Created&gt;\")}\n  hook-updated={() =&gt; console.log(\"Component &lt;Updated&gt;\")}\n  hook-removed={() =&gt; console.log(\"Component &lt;Removed&gt;\")}\n&gt;\n  {/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"on-events/","title":"HTML/Preact \"ON\" Events","text":"<p>on-kebab-case</p> <p>A convenient wrapper for the original events used in Preact, designed to simplify event listener binding. With <code>on-</code> followed by <code>kebab-case</code>, common event handlers such as <code>onClick</code> are effortlessly transformed, enabling more intuitive and concise event handling. This cleaner syntax provides a seamless way to attach event listeners to elements in your Preact application, enhancing code readability and maintainability.</p> <p>Example:</p> <pre><code>&lt;button on-click={() =&gt; console.log(\"clicked\")} x-html&gt;\nClick Me\n&lt;/button&gt;\n</code></pre> <p>Description</p> <p>Event Listener For...</p> Directive Description on-click Click events. on-dbl-click Double-click events. on-context-menu Context menu events. on-mouse-down Mouse down events. on-mouse-up Mouse up events. on-mouse-enter Mouse enter events. on-mouse-leave Mouse leave events. on-mouse-move Mouse move events. on-key-down Key down events. on-key-up Key up events. on-key-press Key press events. on-focus Focus events. on-blur Blur events. on-change Change events. on-input Input events. on-submit Submit events. on-touch-start Touch start events. on-touch-move Touch move events. on-touch-end Touch end events. on-touch-cancel Touch cancel events. on-wheel Wheel events. on-scroll Scroll events. on-copy Copy events. on-cut Cut events. on-paste Paste events. on-composition-start Composition start events. on-composition-update Composition update events. on-composition-end Composition end events. on-load Load events. on-error Error events. on-animation-start Animation start events. on-animation-end Animation end events. on-animation-iteration Animation iteration events. on-transition-end Transition end events."},{"location":"preact/","title":"Preact (Browser)","text":"<p>Tip</p> <p>A preact wrapper for standalone usage in the browser.</p>"},{"location":"preact/#usage","title":"Usage","text":"<pre><code>const { signal } = preact;\n</code></pre>"},{"location":"preact/#properties","title":"Properties","text":"Key Description <code>h</code> Preact core <code>h</code>, used for creating virtual DOM elements. <code>render</code> Preact core <code>render</code>, used for rendering virtual DOM elements to the real DOM. <code>useState</code> Preact <code>hook</code> for managing state in functional components. <code>useEffect</code> Preact <code>hook</code> for handling side effects in functional components. <code>useRef</code> Preact <code>hook</code> for creating mutable references in functional components. <code>useCallback</code> Preact <code>hook</code> for memoizing functions in functional components. <code>signal</code> Preact <code>signals</code> for managing state in functional components. <code>computed</code> Preact <code>signals</code> used for creating computed values. <code>effect</code> Preact <code>signals</code> used for creating effects that react to signal changes. <code>batch</code> Preact <code>signals</code> used for batching multiple signal updates into a single re-render. <code>useSignalEffect</code> Preact <code>signals</code> signals for handling side effects in functional components that depend on signals. <code>useSignal</code> Preact <code>signals</code> signals for subscribing to a signal and re-rendering the component on signal change. <code>useComputed</code> Preact <code>signals</code> signals for creating and using computed values in functional components."},{"location":"router/","title":"Router","text":"<p>Router</p> <p>The <code>xtyle.Router</code> and <code>xtyle.router</code> provide powerful routing capabilities for your application. The <code>xtyle.Router</code> is designed as an initializer to keep track of parameter changes without immediately rendering a view, promoting flexibility in managing routes. On the other hand, the <code>xtyle.router</code> acts as your router's manager.</p>"},{"location":"router/#dynamic-path-patterns","title":"Dynamic Path Patterns","text":"<p>When defining routes, you can use dynamic path patterns to handle different scenarios:</p> <ul> <li><code>/{variable}</code>: Encapsulating a word with <code>{}</code> brackets makes it a required path parameter.</li> <li><code>/{?variable}</code>: The <code>?</code> at the start indicates that the parameter is optional.</li> <li><code>/{variable*}</code>: The <code>*</code> at the end denotes a wildcard parameter, which matches the remaining part of the path.</li> </ul>"},{"location":"router/#configuration-example","title":"Configuration (Example)","text":"<p>Here's an example of how to initialize the router and configure it with options and route patterns:</p> <p>Path Patterns (Examples)</p> <ul> <li> <p><code>/a/some-{key}</code> : This one is required!</p> </li> <li> <p><code>/a/b-{?key}</code> : The \"<code>?</code>\" indicates that the parameter <code>key</code> is optional.</p> </li> <li> <p><code>/a/b/{path*}</code> : The \"<code>*</code>\" denotes a wildcard parameter named <code>path</code>, which matches the remaining part of the path.</p> </li> </ul> <p>xtyle.Router</p> <pre><code>/**\n * Define the list of route patterns\n */\nconst patternList = [\"/\", \"/a/b/{?key}\", \"/a/b/key-{name}/{path*}\"];\n/**\n * Initialize the router with options\n */\nxtyle.Router({\nhistory: false,\nbaseURL: \"/\",\nroutes: patternList,\ncallback: () =&gt; {\nconsole.log(\"Changed\");\n},\n});\n</code></pre>"},{"location":"router/#options","title":"Options","text":"Key Description <code>history</code> A boolean flag indicating whether to use the history API for routing. <code>baseURL</code> The base URL for the router. <code>routes</code> The list of route patterns to use for routing. <code>callback</code> A callback <code>function</code> that will be executed when the route changes. <p>history</p> <p>The <code>history</code> option is a boolean flag that determines the routing behavior.</p> <ul> <li>If set to <code>false</code>, paths will use the \"#\" prefix, indicating the use of the hash-based routing strategy.</li> <li>If set to <code>true</code>, the router will use the regular history API for navigation, allowing for cleaner URLs without the \"#\" symbol.</li> </ul>"},{"location":"router/#properties","title":"Properties","text":"Key Description current Get the current router's info."},{"location":"router/#methods","title":"Methods","text":"Key Description go Navigate to a specific path and optionally add a URL query via an object. effect Preact effect wrapper for easy access to router effects. computed Preact computed wrapper for easy creation of computed values."},{"location":"router/#special-keys","title":"Special ${Keys}","text":"Key Description $action Converts to URL query parameter <code>__a</code> to define a backend action for the route. $query Converts to URL query parameter <code>__q</code> to pass query parameters as a JSON string to the route."},{"location":"router/#navigate-demo","title":"Navigate (Demo)","text":"<p>xtyle.router</p> <pre><code>/**\n * Navigate to a new path with query parameters\n */\nxtyle.router.go(\n\"/home\", // Path\n// Query\n{\nkey: \"val\",\n$action: \"app.model.filter\",\n$query: { key: \"val\" },\n}\n);\n</code></pre>"},{"location":"router/#computed-effect-demo","title":"Computed &amp; Effect (Demo)","text":"<p>xtyle.router</p> <pre><code>/**\n * Create a computed value based on the current route\n */\nconst currentSearch = xtyle.router.computed(() =&gt; {\nreturn xtyle.router.current.search;\n});\n/**\n * Add an effect to be triggered when the route changes\n */\nxtyle.router.effect(() =&gt; {\n// Log an example value from the `router.current.search` object\nconsole.log(currentSearch.value);\n});\n/**\n * Set an interval to navigate after a certain time\n */\nsetInterval(() =&gt; {\nxtyle.router.go(\"/about\", {\nkey: new Date().toISOString(),\n});\n}, 1000);\n</code></pre> <p>With the Xtyle Router module, you can easily manage your application's routing, handle dynamic path patterns, and perform actions when the route changes, providing a smooth user experience and better control over your application's navigation.</p>"},{"location":"control-flow/fallback/","title":"x-fallback and x-fallback-is","text":"<p>x-fallback and x-fallback-is<p>Combination of utilities that provides a seamless way to display a fallback component in case of rendering issues with the main component.</p> <p>With <code>x-fallback</code> and <code>x-fallback-is</code>, you can easily handle scenarios where the main component encounters errors or is still loading, ensuring a smooth user experience. Simply specify the fallback component and conditionally render it when needed. Enhance error handling and loading states with the versatility of <code>x-fallback</code> and <code>x-fallback-is</code>.</p> </p> <p>Example:</p> <pre><code>&lt;x-slot x-fallback-is={true} x-fallback={&lt;h1&gt;Loading...&lt;/h1&gt;}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/for/","title":"x-for and x-in","text":"<p>x-for and x-in<p>Powerful utilities that enable effortless looping through an array or range to render elements for each item.</p> <p>With <code>x-for</code> and <code>x-in</code>, you can easily iterate over an array of items or a range defined by an integer number, rendering elements dynamically. Simplify repetitive rendering tasks and enhance code readability with the flexibility of <code>x-for</code> and <code>x-in</code>.</p> </p> <p>Example:</p> <pre><code>&lt;x-slot x-for={(item) =&gt; &lt;li&gt;{item}&lt;/li&gt;} x-in={[\"one\", \"two\", \"three\"]}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/x-slot&gt;\n</code></pre> <p>Range Example:</p> <pre><code>&lt;x-slot x-for={(item) =&gt; &lt;li&gt;{item}&lt;/li&gt;} x-in={3}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/if/","title":"x-if","text":"<p>x-if<p>Utility for enabling conditional rendering of elements based on specified conditions. With x-if, you can effortlessly control whether an element should be rendered or hidden, depending on the truthiness of the provided condition. This feature allows you to create dynamic and responsive user interfaces by conditionally showing or hiding elements as needed. Simplify your component logic and enhance user experiences with the flexibility of x-if.</p> </p> <p>Example:</p> <pre><code>function Component(props) {\nconst status = preact.useSignal(false);\nreturn (\n&lt;div x-html x-if=\"{status.value}\"&gt;\nHide and Seek\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"control-flow/live/","title":"x-live","text":"<p>x-live<p>Utility that dynamically renders a component based on the provided callback function.</p> <p>With <code>x-live</code>, you can create highly flexible and dynamic components that adapt their content based on the callback's output. This feature allows you to generate custom UI elements or complex structures on the fly, providing a more interactive and adaptive user experience. Unlock the full potential of component rendering with the versatility of <code>x-live</code>.</p> </p> <p>Example:</p> <pre><code>&lt;x-slot x-live={(p) =&gt; &lt;h2&gt;{p.title}&lt;/h2&gt;} title=\"My Component\" /&gt;\n</code></pre>"},{"location":"control-flow/portal/","title":"x-portal","text":"<p>x-portal</p> <p>Utility that enables portal rendering, allowing elements to be rendered outside the component's DOM.</p> <p>With <code>x-portal</code>, you can seamlessly render content into a specified target container, even if it exists outside the current component's hierarchy. This feature is particularly useful for implementing modals, overlays, or other UI elements that need to be rendered at a different location in the DOM. Simplify your component architecture and enhance flexibility with the convenience of <code>x-portal</code></p> <p>By using <code>x-fragment</code> in combination with <code>x-portal</code>, you can create a Document Fragment, a lightweight container that allows you to group multiple elements together without adding additional nodes to the DOM. This can be helpful when you need to render multiple elements as a single unit.</p> <p>Example (Component):</p> <p>Re-renders</p> <p>This re-renders! Replacing anything in the selected container.</p> <pre><code>&lt;x-slot x-portal=\"#modal\"&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/x-slot&gt;\n</code></pre> <p>Example (Fragment):</p> <p>Appends</p> <p>This appends to the selected container.</p> <pre><code>&lt;x-slot x-portal=\"#modal\" x-fragment&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/x-slot&gt;\n</code></pre>"},{"location":"control-flow/show/","title":"x-show","text":"<p>x-show<p>Utility for enabling conditional display with CSS class manipulation.</p> <p>With <code>x-show</code>, you can easily control whether an element should be shown or hidden based on the truthiness of the provided condition. This feature allows you to apply CSS classes dynamically to toggle the element's visibility, resulting in a more interactive and responsive user interface.</p> </p> <p>Example:</p> <pre><code>function Component(props) {\nconst status = preact.useSignal(false);\nreturn (\n&lt;div x-html x-show=\"{status.value}\"&gt;\nHide and Seek\n&lt;/div&gt;\n);\n}\n</code></pre>"},{"location":"control-flow/switch/","title":"x-switch and x-case then case","text":"<p>x-switch | x-case | case<p>A powerful trio of utilities that allow you to conditionally render content based on a switch case.</p> <p>With <code>x-switch</code>, <code>x-case</code>, and <code>case</code>, you can easily handle different scenarios and render specific content for each case. This feature is particularly useful for creating dynamic views and managing conditional rendering in a more organized and concise manner. Simplify your component logic and enhance code readability with the versatility of <code>x-switch</code>, <code>x-case</code>, and <code>case</code>.</p> </p> <p>Example:</p> <pre><code>function View() {\nconst text = preact.useSignal(\"one\");\nreturn (\n{/* &lt;!-- x-switch and x-case... --&gt; */}\n&lt;x-slot x-switch x-case={text.value}&gt;\n{/* &lt;!-- then... case --&gt; */}\n&lt;x-slot\nx-for={(item) =&gt; &lt;x-slot case={item}&gt;Page {item}&lt;/x-slot&gt;}\nx-in={[\"one\", \"two\", \"three\"]}\n&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/x-slot&gt;\n&lt;/x-slot&gt;\n);\n}\n</code></pre>"},{"location":"directives/click-outside/","title":"x-click-outside","text":"<p>x-click-outside<p>Utility that actively listens for clicks outside the specified element and automatically triggers a callback function. With <code>x-click-outside</code>, you can effortlessly capture clicks occurring outside the element and respond with custom actions or behavior. This feature is particularly valuable for scenarios like closing pop-ups, modals, or dropdowns when users interact with elements outside of them.</p> </p> <p>Example:</p> <pre><code>&lt;div\nx-html\nx-click-outside={({ self }) =&gt; console.log(\"Clicked outside\")}\n&gt;&lt;/div&gt;\n</code></pre>"},{"location":"directives/hover/","title":"x-hover","text":"<p>x-hover<p>Designed to handle hover events with ease. Use <code>x-hover</code> to effortlessly manage interactions triggered by hovering over elements. This utility empowers you to define custom actions or styles when users hover over specific elements, enhancing the interactivity and visual feedback of your application.</p> </p> <p>Example:</p> <pre><code>&lt;div x-html x-hover={({ value }) =&gt; console.log(value)}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/ref/","title":"x-ref","text":"<p>x-ref</p> <p>A utility function designed for efficiently handling the <code>useRef()</code> value of the current <code>&lt;element-component&gt;</code>.</p> <p>With <code>x-ref</code>, you can easily access and interact with the current value of the referenced element component. This allows you to perform actions on the referenced element without triggering re-renders.</p> <p>Simplify your element management and optimize performance with <code>x-ref</code>.</p> Key Description <code>ref.add</code> Add class(es) to the DOM element <code>ref.remove</code> Remove class(es) to the DOM element <code>ref.toggle</code> Toggle class(es) to the DOM element <code>ref.contains</code> Check if DOM element Contains a class <code>ref.get</code> Run <code>querySelector</code> on DOM element <code>ref.find</code> Run <code>querySelectorAll</code> on DOM element <p>Example:</p> <pre><code>function Component(props) {\nlet ref = null;\nreturn (\n&lt;div x-ref={(self) =&gt; (ref = self)} x-html&gt;\nContent goes here...\n&lt;/div&gt;\n);\n}\n</code></pre> <p>Usage:</p> <pre><code>// Current\nref.current;\n// Utils\nref.add(\"class-after-init\");\nref.remove(\"class-after-init\");\nref.toggle([\"toggled-classes\"], true);\nref.contains(\"toggled-classes\");\n// Children Utils\nref.get(\".one-child\");\nref.find(\".all-children\");\n</code></pre>"},{"location":"directives/resize/","title":"x-resize","text":"<p>x-resize<p>Utility that effectively handles resize events with ease. With <code>x-resize</code>, you can effortlessly manage interactions triggered by resizing the window. This utility empowers you to define custom actions or styles when the element's size changes, providing a more responsive and adaptable user experience.</p> <p>Simplify event handling and optimize your application's behavior with the flexibility of <code>x-resize</code>.</p> </p> <p>Example:</p> <pre><code>&lt;div x-html x-resize={({ event }) =&gt; console.log(event)}&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/ripple/","title":"x-ripple","text":"<p>x-ripple<p>A delightful utility that adds an elegant ripple effect to elements, enhancing visual feedback and interactivity. With <code>x-ripple</code>, you can effortlessly elevate the user experience by providing a subtle animation when elements are interacted with. Create a more engaging and polished interface with the power of <code>x-ripple</code>.</p> </p> <p>Example:</p> <pre><code>&lt;button x-html x-ripple&gt;\n{/*\n  &lt;!-- Content goes here... --&gt;\n  */}\n&lt;/button&gt;\n</code></pre> <p>Config Example:</p> <pre><code>&lt;button\nx-html\nx-ripple={{\ncenter: true,\ncircle: true,\ncolor: \"red\",\nclass: \"my-class\",\n}}\n&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/button&gt;\n</code></pre>"},{"location":"directives/scroll/","title":"x-scroll","text":"<p>x-scroll</p> <p>Utility that facilitates handling scroll events and executing actions within the current element. With <code>x-scroll</code>, you can seamlessly manage scroll interactions and define custom behaviors when users scroll within the element.</p> <p>Enhance interactivity and user experiences by leveraging the power of <code>x-scroll</code> to create dynamic and engaging content.</p> <p>Example:</p> <pre><code>&lt;div\nx-html\nx-scroll={({ value, self }) =&gt; {\n/* ... */\nconsole.log(value);\nself.ref.toggle([\"they-see-me-scrolling\"]);\n}}\n&gt;\n{/* &lt;!-- Content goes here... --&gt; */}\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/swipe/","title":"x-swipe","text":"<p>x-swipe<p>Utility that enables seamless detection of swipe gestures and emits the corresponding direction. With x-swipe, you can easily recognize and respond to swipe interactions, providing valuable input for navigating or triggering actions within your application. Enhance user experiences and simplify swipe gesture handling with the power of <code>x-swipe</code>.</p> </p> <p>Example:</p> <pre><code>&lt;div x-html x-swipe={({ value }) =&gt; console.log(\"side \" + value)}&gt;\nSwipe me\n&lt;/div&gt;\n</code></pre>"},{"location":"directives/value/","title":"x-value and x-value-clean","text":"<p>x-value<p>It efficiently updates the value of the specified Preact <code>signal</code> based on the provided element's input-type. When used with input elements (<code>input</code>,<code>textarea</code>, <code>select</code>, <code>progress</code>), <code>x-value</code> allows seamless synchronization between the element's value and the corresponding <code>signal</code>, ensuring your application stays in sync with user input. Simplify state management and enhance data flow with the <code>x-value</code> function.</p> </p> <p>x-value-clean<p>You can clean/filter the value before updating the state and element's value.</p> </p> <p>x-value-validators<p>You can validate the value after you filter it.</p> </p> <p>x-input<p>Useful for extending an input component.</p> <ul> <li>Get the current <code>value</code></li> <li>Submit if the value is <code>valid</code></li> <li>Present <code>errors</code> to the client</li> </ul> </p> <pre><code>function Component(props) {\nconst text = preact.useSignal(\"\");\nreturn (\n&lt;input\nx-html\nx-input={({ value, valid, errors }) =&gt;\nconsole.log({ value, valid, errors })\n}\nx-value={text}\nx-value-clean={(value) =&gt; value.toLowerCase()}\nx-value-validators={[\n(v) =&gt; v.length === 0 || \"Required Field!\",\n(v) =&gt; v.length &gt;= 8 || \"At least 8 characters long\",\n]}\n/&gt;\n);\n}\n</code></pre>"},{"location":"util/i18n/","title":"i18n","text":"<p>xtyle.i18n</p> <p>The i18n (internationalization) allows you to handle translations in your project effectively. With <code>xtyle.translations</code>, you can register translation object, and later, you can access those translations using <code>xtyle.i18n</code>.</p>"},{"location":"util/i18n/#register-translations","title":"Register Translations","text":"<p>To set up translations, you need to use the <code>xtyle.translations</code> method. It takes an object as input.</p> <pre><code>/* Set Translations */\nxtyle.translations({\nfr: {\ngreetings: {\nhello: \"Bonjour!\",\n},\n},\n});\n</code></pre> <p>In this example, we're registering a single translation for the French language. You can add more translations for different languages by extending the <code>xtyle.translations</code> object with additional language codes and their respective translations.</p>"},{"location":"util/i18n/#access-translations","title":"Access Translations","text":"<p>The <code>xtyle.i18n</code> method takes a single argument, which is a dot-separated string representing the path to the translation you want to retrieve.</p> <p>The format of the string is <code>path_to.translation_key</code>.</p> <p>Here's an example of how to use <code>xtyle.i18n</code> to retrieve the French greeting we registered earlier:</p> <pre><code>/* Preview */\nconsole.log(\"i18n: \", xtyle.i18n(\"fr.greetings.hello\"));\n</code></pre> <p>In this case, the output will be:</p> <pre><code>i18n: Bonjour!\n</code></pre> <p>By using <code>xtyle.i18n</code>, you can easily access the translations you registered globally throughout your project and display content in different languages based on the user's preference or the context of your application.</p>"},{"location":"util/models/","title":"Model","text":"<p>xtyle.model</p> <p>Register tables that are reactivity powered by Preact's <code>signal</code>, <code>effect</code>, and <code>computed</code> methods. It offers a wide range of data operations, enabling efficient management and manipulation of records within the virtual database.</p>"},{"location":"util/models/#properties","title":"Properties","text":"<ul> <li>info: Provides information about the table.</li> </ul> Key Description mode Gets or sets the current mode of the table (e.g., \"list\", \"edit\", \"create\"). form Gets or sets the form data (editable record) for the table. list Gets or sets the list of records in the table."},{"location":"util/models/#reactive-methods","title":"Reactive Methods","text":"Key Description computed Creates a computed value based on the provided method. effect Adds an effect to be triggered when the table state changes. updateList Updates the list of records using the provided method. updateForm Updates the form data (editable record) using the provided method."},{"location":"util/models/#table-methods","title":"Table Methods","text":"Key Description head Returns the first (N) records from the table. tail Returns the last (N) records from the table. by Returns records grouped by the specified column key. sort Sorts the records in ascending or descending order based on the provided column(s). groupBy Groups records in the list based on the specified column key. find Finds records in the list that match the specified column and value. findNot Finds records in the list that do not match the specified column and value. search Filters records that match the search value in the specified column(s). searchNot Filters records that do not match the search value in the specified column(s). dirtyList Returns records that have been updated compared to the current list. dirtyForm Returns the updated values in the form compared to the current form."},{"location":"util/models/#example","title":"Example","text":"<p>This demo showcases the usage of the xtyle.table wrapper to manage a virtual database table.</p>"},{"location":"util/models/#table-creation-and-setup","title":"Table Creation and Setup","text":"<pre><code>// Create a new database table instance named \"app.model\"\nconst table = xtyle.model(\"app.model\");\n</code></pre>"},{"location":"util/models/#initial-data-setup","title":"Initial Data Setup","text":"<pre><code>// Set the initial list of records for the table\ntable.list = [\n{ id: 1, text: \"ITEM 1\" },\n{ id: 2, text: \"ITEM 2\" },\n{ id: 3, text: \"ITEM 3\" },\n{ id: 4, text: \"ITEM 4\" },\n{ id: 5, text: \"ITEM 5\" },\n];\n</code></pre>"},{"location":"util/models/#asynchronous-updates","title":"Asynchronous Updates","text":"<pre><code>// Define a computed value to search for records with \"text\" containing \"item 5\"\nconst demo = table.computed((self: any) =&gt; self.search(\"text\", \"item 5\"));\n// After 1 second, remove the last record from the table using `updateList` method\nsetTimeout(() =&gt; {\ntable.updateList((items) =&gt; {\nitems.pop();\n});\n// Update the form data by adding a new key \"key\" with the value \"one\"\ntable.updateForm((form) =&gt; {\nform.key = \"one\";\n});\n// Update the form data again by deleting the key \"key\"\ntable.updateForm((form) =&gt; {\ndelete form.key;\n});\n}, 1000);\n</code></pre>"},{"location":"util/models/#effects","title":"Effects","text":"<pre><code>// Add an effect to log the current mode and form data whenever they change\ntable.effect(() =&gt; {\nconsole.log(table.mode);\nconsole.log(table.form);\n});\n// Add an effect to log the current list and the computed result \"demo.value\"\ntable.effect(() =&gt; {\nconsole.log(table.list);\nconsole.log(demo.value);\n});\n</code></pre>"}]}